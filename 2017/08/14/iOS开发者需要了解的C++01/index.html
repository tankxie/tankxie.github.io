<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Objective-C++," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="本文翻译自Introduction to C++ for iOS Developers: Part 1﻿   为了促使自己更认真的看文章，看完之后随手翻译了一把，里面有翻译不准的欢迎指正，看完之后，墙裂推荐，看一下原文！  如果你已经掌握了Objective-C了，正在寻找下一个很酷的东西去学习，尝试本篇文章吧，本篇文章为iOS开发者介绍C++。 正如我稍后解释，Objective-C、C和C +">
<meta name="keywords" content="Objective-C++">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS开发者需要了解的C++01">
<meta property="og:url" content="http://yoursite.com/2017/08/14/iOS开发者需要了解的C++01/index.html">
<meta property="og:site_name" content="tankxie&#39;s blogs">
<meta property="og:description" content="本文翻译自Introduction to C++ for iOS Developers: Part 1﻿   为了促使自己更认真的看文章，看完之后随手翻译了一把，里面有翻译不准的欢迎指正，看完之后，墙裂推荐，看一下原文！  如果你已经掌握了Objective-C了，正在寻找下一个很酷的东西去学习，尝试本篇文章吧，本篇文章为iOS开发者介绍C++。 正如我稍后解释，Objective-C、C和C +">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-08-15T13:04:59.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS开发者需要了解的C++01">
<meta name="twitter:description" content="本文翻译自Introduction to C++ for iOS Developers: Part 1﻿   为了促使自己更认真的看文章，看完之后随手翻译了一把，里面有翻译不准的欢迎指正，看完之后，墙裂推荐，看一下原文！  如果你已经掌握了Objective-C了，正在寻找下一个很酷的东西去学习，尝试本篇文章吧，本篇文章为iOS开发者介绍C++。 正如我稍后解释，Objective-C、C和C +">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/08/14/iOS开发者需要了解的C++01/"/>





  <title>iOS开发者需要了解的C++01 | tankxie's blogs</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">tankxie's blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/14/iOS开发者需要了解的C++01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tank">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://www.vstou.com/upload/image/355/201606/1465004143320282.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tankxie's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">iOS开发者需要了解的C++01</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-14T21:26:50+08:00">
                2017-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本文翻译自<a href="https://www.raywenderlich.com/62989/introduction-c-ios-developers-part-1" target="_blank" rel="external">Introduction to C++ for iOS Developers: Part 1﻿</a></p>
<blockquote>
<p> 为了促使自己更认真的看文章，看完之后随手翻译了一把，里面有翻译不准的欢迎指正，看完之后，墙裂推荐，看一下原文！</p>
</blockquote>
<p>如果你已经掌握了Objective-C了，正在寻找下一个很酷的东西去学习，尝试本篇文章吧，本篇文章为iOS开发者介绍C++。</p>
<p>正如我稍后解释，Objective-C、C和C ++代码能无缝协调工作。 因此，对于iOS开发人员来说，学习理解C ++有以下几个理由：</p>
<ul>
<li>有时你可能想要在APP中调用C ++编写的library。</li>
<li>你可能希望在C ++中编写应用程序的一部分代码，从而更容易跨平台移植。</li>
<li>掌握其他语言的良好基础，可以帮助你更好地了解编程。</li>
</ul>
<p>本文是针对已经了解Objective-C的iOS开发人员编写的。 假设你已经了解如何编写Objective-C代码，并熟悉C语言的基本概念，如类型，指针和函数。</p>
<p>准备好了么？接下来我们开始学习吧！</p>
<h1 id="1-Getting-Started-A-Brief-History-of-Languages"><a href="#1-Getting-Started-A-Brief-History-of-Languages" class="headerlink" title="1. Getting Started: A Brief History of Languages"></a>1. Getting Started: A Brief History of Languages</h1><p>C++和Objective-C同源：他们都来源于古老的C。这意味着它们都是C语言的“超集”（supersets）。 因此，在两种语言中，你可以使用C语言语法以及他们各自的特性。</p>
<p>如果你熟悉Objective-C，你可能对C ++代码有一个粗略的了解。 例如，诸如int，float和char之类标量类型的存在，并且在两种语言中的行为和表现方式完全相同。</p>
<p>Objective-C和C ++都将面向对象的功能添加到C。如果你还不熟悉“面向对象”这个术语，你需要了解的是，<strong>“面向对象”意味着数据通过对象表示，而对象又是类的实例</strong>。 事实上，C ++最初被称为“C with Classes”，它显示了使C++面向对象的基本愿望。</p>
<p>那么，你会问：“他们的差异在哪呢？”。 那么主要的区别就在面向对象特征的方式上（the approach to the object-oriented features）。 在C++中，很多操作在<strong>编译时</strong>发生，而在Objective-C中，<strong>运行时</strong>会发生更多的事情。 你可能已经使用Objective-C运行时来执行诸如方法转换（method swizzling）。 在C ++中，这根本就不可能。</p>
<p>C ++也没有Objective-C有过多的内省和反思方法（ <strong>introspection and reflection methods</strong>）。 没有办法像Objective-C那样在实例中简单地调用“类”方法来获取C++对象的类。 类似地，在C ++中没有等价于﻿<code>isMemberOfClass</code>﻿或<code>isKindOfClass</code>。</p>
<p>这是对C ++的粗略的介绍，显示了它与Obejctive-C之间的历史和主要区别。 下面开始继续介绍C++类。</p>
<h1 id="2-C-Classes"><a href="#2-C-Classes" class="headerlink" title="2.C++ Classes﻿"></a>2.C++ Classes﻿</h1><p>在任何面向对象语言中需要知道的第一件事是，如何定义一个类。 </p>
<p>在Objective-C中，创建一个头文件和一个实现文件来定﻿义一个类。 完全相同的事情发生在C ++中; 语法也很熟悉。<br>这是一个Objective-C类的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">MyClass.h</div><div class="line"></div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface MyClass : NSObject</div><div class="line">@end</div><div class="line"></div><div class="line">// MyClass.m</div><div class="line"></div><div class="line">#import “MyClass.h”</div><div class="line"></div><div class="line">@implementation MyClass</div><div class="line">@end﻿​</div></pre></td></tr></table></figure>
<p>对于iOS作为经验丰富的iOS开发人员来说，上述代码你是清楚的。 接下来看看C ++中的类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// MyClass.h</div><div class="line"></div><div class="line">class MyClass &#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// MyClass.cpp</div><div class="line"></div><div class="line">#include “MyClass.h”</div><div class="line"></div><div class="line">/* Nothing else in here */</div></pre></td></tr></table></figure>
<p>这里有一些明显的区别。 首先是C++中的实现文件没有任何内容，那是因为你没有在类上声明任何方法。 同样，空类也不需要像Objective-C那样的<code>@implemenation</code>/ <code>@end</code>块。</p>
<p>在Objective-C中，每个类几乎总是从<code>NSObject</code>继承。 你可以创建自己的根类，这意味着你的类不会有superclass，但是，除非你使用运行时（runtime），否则你不可能执行此操作。 这与C ++不同，在C++里，创建一个没有superclass的类是很常见的，如上例所示。</p>
<p>另一个微小的区别是<code>#include</code> vs. <code>#import</code>。 Objective-C将#import预处理程序指令添加到C。在C ++中没有等价物，因此使用标准C风格的#include。<strong> Objective-C的#import确保文件只包含一次，但在C++中，你必须自己执行此检查。</strong></p>
<h1 id="3-Class-Member-Variables-and-Functions"><a href="#3-Class-Member-Variables-and-Functions" class="headerlink" title="3.Class Member Variables and Functions"></a>3.Class Member Variables and Functions</h1><p>当然，一个类还有不仅仅只是声明它。 就像Objective-C一样，在C ++中，你可以向实例类添加实例变量（ <strong>instance variables</strong>）和方法（ <strong>methods</strong>）。你可能会听到他们在C ++中的不同定义; 它们通常被称为成员变量（<strong>member variables</strong>）和成员函数（<strong>member functions</strong>）。</p>
<blockquote>
<p>注意：术语“方法（methods）”并不真正用于C ++。 区别仅在Objective-C中，方法通过消息派发（message dispatch）调用。 另一方面，函数（function）是通过静态C风格的函数调用来调用的。 本文稍后将介绍静态与动态的更多内容。﻿</p>
</blockquote>
<p>那么，你如何声明成员变量和成员函数呢？ 那么这里有一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class MyClass &#123;</div><div class="line">    int x;</div><div class="line">    int y;</div><div class="line">    float z;</div><div class="line"></div><div class="line">    void foo();</div><div class="line">    void bar();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里有三个成员变量和两个成员函数。 </p>
<p>但是，在C++实际开发中你还可以进行更多操作，因为你可以限制C ++中的成员变量和成员函数的<strong>范围</strong>（scope），并将其声明为公开或私有可访问的。 这可以用来限制哪些代码可以访问每个变量或函数，示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class MyClass &#123;</div><div class="line">  public:</div><div class="line">    int x;</div><div class="line">    int y;</div><div class="line">    void foo();</div><div class="line"></div><div class="line">  private:</div><div class="line">    float z;</div><div class="line">    void bar();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里，x，y和foo是可公开访问的。这意味着它们可以在MyClass类之外使用。 但是，z和bar是私有的。 这意味着它们只能在MyClass内使用。 <strong>成员变量默认为私有</strong>。</p>
<p>虽然Objective-C中存在这种变量区分，但很少使用它。 另一方面，Objective-C不可能限制方法的范围。 即使你只在一个类的实现中声明一个方法，并且不将它暴露在接口中，你在技术上仍然可以从外部调用该方法。</p>
<p>Objective-C中的方法只有公开或仅仅按照惯例的私有（没有真正的私有）。 这就是为什么很多开发人员选择使用诸如“p_”之类的私有方法来表示区别。 这与C ++不同，如果您尝试从类外部调用私有方法，编译器将抛出错误。</p>
<p>那么你如何使用一个类？ 和Objective-C相似。 你创建一个这样的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">MyClass m;</div><div class="line">m.x = 10;</div><div class="line">m.y = 20;</div><div class="line">m.foo();</div></pre></td></tr></table></figure>
<p>就那么简单！ 这将创建一个MyClass的实例，将x和y分别设置为10和20，然后调用foo。</p>
<h1 id="4-Implementing-Class-Member-Functions"><a href="#4-Implementing-Class-Member-Functions" class="headerlink" title="4.Implementing Class Member Functions"></a>4.Implementing Class Member Functions</h1><p>你已经看到了如何定义一个类接口，但是如何实现函数呢？事实证明，这很简单。 有几种方法可以做到这一点。 的第一种实现方法是通过在类的实现文件 —- .cpp文件中定义它。 你可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//MyClass.h</div><div class="line">classMyClass&#123;</div><div class="line">intx;</div><div class="line">inty;</div><div class="line">voidfoo();</div><div class="line">&#125;;</div><div class="line">//MyClass.cpp</div><div class="line">#include“MyClass.h”</div><div class="line">MyClass::foo()&#123;</div><div class="line">//Dosomething</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是第一种方式 它与Objective-C中如何做到非常相似。 注意，使用<code>MyClass ::</code>; 这是你如何表示foo() 函数被实现为MyClass类的一部分。</p>
<p>实现方法的第二种方法是在Objective-C中不能做的事情。 在C ++中，你可以直接在头文件中实现一个方法，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//MyClass.h</div><div class="line">classMyClass&#123;</div><div class="line">intx;</div><div class="line">inty;</div><div class="line">voidfoo()&#123;</div><div class="line">//Dosomething</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果你仅使用过Objective-C，这可能对你来说看起来很奇怪。 这是相当奇怪的，但它也可以是非常有用的。 当以这种方式声明函数时，编译器可以执行称为“<strong>内联（inlining）</strong>”的优化。<strong> 这意味着当调用此函数时，而不是跳转到新的代码块，整个功能代码在调用处内联编译。</strong></p>
<p>虽然内联可以使代码更快，但它也会增加编译代码的大小，因为如果函数多次被调用，代码将在整个二进制文件中复制。 如果函数相当大或被调用了很多次，那么这可能会对二进制文件的大小产生重大影响。 这可能导致性能下降，因为较少的代码可以适应缓存，这意味着可能存在更多的高速缓存未命中。</p>
<p>我的目标是说明C ++允许很多的灵活性。 作为开发人员，你需要了解权衡并作出决定。 当然，唯一的方法是真正知道哪个选择适合你，就是调整你的代码！</p>
<h1 id="5-Namespaces"><a href="#5-Namespaces" class="headerlink" title="5.Namespaces"></a>5.Namespaces</h1><p>上面看到的示例介绍了一些你以前没有遇到的新语法 ， 双冒号 —-  <code>::</code>。 这是你如何在C ++中引用范围的; 以上使用它来告诉编译器应该在哪里查找foo函数。</p>
<p>另一次你会看到双冒号是使用命名空间。 命名空间是一种分离代码的方式，因此命名冲突不太可能发生。</p>
<p>例如，你可以在自己的代码中实现一个名为Person的类，但第三方库也可以实现一个名为Person的类。 因此，在编写C ++时，通常将所有代码放入命名空间中，以避免这些类型的命名冲突。</p>
<p>这很容易做到这一点 你只需用以下命名空间声明来包装所有内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">namespaceMyNamespace&#123;</div><div class="line">classPerson&#123;…&#125;;</div><div class="line">&#125;</div><div class="line">namespaceLibraryNamespace&#123;</div><div class="line">classPerson&#123;…&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，当使用Person类的任一实现时，可以使用双冒号来消除歧义，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MyNamespace::PersonpOne;</div><div class="line">LibraryNamespace::PersonpTwo;</div></pre></td></tr></table></figure>
<p>很简单，不是吗？<br>在Objective-C中没有等价的命名空间，只能在类的前面加前缀。</p>
<blockquote>
<p>注意：Objective-C中有几个命名空间的建议。 一个这样的建议可以在这里找到。 我不知道我们是否会在Objective-C中看到他们，但我确实希望如此！</p>
</blockquote>
<h1 id="6-Memory-Management"><a href="#6-Memory-Management" class="headerlink" title="6.Memory Management"></a>6.Memory Management</h1><p>Oh no…不是那个可怕的短语！ 内存管理是任何语言中最重要的事情之一。 Java基本上让垃圾收集器做它的工作。 Objective-C要求你了解引用计数（ reference counting）和ARC所扮演的角色。 在C ++中…好吧，C ++又是一个不同的野兽。</p>
<p>首先，要了解C ++中的内存管理，您真的需要了解<strong>栈</strong>（stack）和<strong>堆</strong>（heap）。 即使你认为你知道这一点，我建议你继续阅读; 你可能会学习以下两两点：</p>
<ul>
<li>stack是供正在运行的应用程序是用的内存块。 它是一个固定的大小，被应用程序的代码用于存储数据。 stack以push/pull为基础; 当给定的函数运行时，它将数据push到堆栈上，当函数完成时，它必须pull相同数量的数据。 因此，随着时间的推移，堆栈使用率将不会增长。</li>
<li>heap也是运行应用程序可用的内存块。 它的大小不固定，并随着应用程序的运行而增长。 应用程存储将“在函数范围之外使用的数据”存储在heap中。 而且，大型数据通常会存储在堆中，因为将其存储在堆栈中可能会溢出堆栈 。请记住，堆栈是固定的大小。</li>
</ul>
<p>这是堆栈和堆理论的一个很简单的概述; 这里有一些C代码显示了实践中的栈和堆：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">intstackInt=5;</div><div class="line">int*heapInt=malloc(sizeof(int));</div><div class="line">*heapInt=5;</div><div class="line">free(heapInt);</div></pre></td></tr></table></figure>
<p>这里，stackInt正在使用栈空间; 函数返回后，用于存储值“5”的内存将自动释放。</p>
<p>然而，heapInt正在使用堆空间。 对malloc的调用在堆上分配足够的空间来存储int变量。 但是，由于堆必须由开发人员进行管理，因此，在完成数据后，需要进行释放这一片堆空间，以确保不会泄漏内存。    </p>
<p>在Objective-C中，只能在堆上创建对象; 如果您尝试在栈上创建一个对象，则会收到编译器错误。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSStringstackString;</div><div class="line">//Untitled32.m:5:18:error:interfacetypecannotbestaticallyallocated</div><div class="line">//NSStringstackString;</div><div class="line">//^</div><div class="line">//*</div><div class="line">//1errorgenerated</div></pre></td></tr></table></figure></p>
<p>这就是为什么你会看到，全部Objective-C代码创建的对象，都带有星号; 所有对象都在堆上创建，并且返回指向这些对象的指针。 这主要归结于Objective-C处理内存管理的方式。 对象需要在堆上，通过引用计数，使其生命周期得到严格的控制。</p>
<p>在C ++中，您可以决定将数据存储在堆栈或堆上; 选择取决于开发人员。 但是，在C ++中，必须自己管理内存。 存放在栈中的数据会自动进行处理，但是当你开始使用堆时，必须自己处理内存管理，处理不好有内存泄露的风险。</p>
<h1 id="7-C-new-and-delete"><a href="#7-C-new-and-delete" class="headerlink" title="7.C++ new and delete"></a>7.C++ new and delete</h1><p>C ++引入了几个关键字来帮助<strong>堆对象</strong>的内存管理; 它们用于创建和销毁堆上的对象。<br>创建对象是这样完成的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person *person = new Person();</div></pre></td></tr></table></figure>
<p>当你完成对象后，你可以像这样释放它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">delete person;</div></pre></td></tr></table></figure>
<p>实际上，这甚至适用于C ++中的标量类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int *x = new int();</div><div class="line">*x = 5;</div><div class="line">delete x;</div></pre></td></tr></table></figure>
<p>您可以将这些操作看作与Objective-C中对象初始化和销毁相同的操作。 在C ++中使用新的<code>Person（）</code>初始化，相当于Objective-C中的<code>[[Person alloc] init]</code>。</p>
<p>不过Objective-C中没有和<code>delete</code>等价的关键字。 我确定你知道，一个Objective-C对象的释放由运行时处理，当它的<strong>引用计数</strong>降到零时。 记住，C++不会为你引用计数。 完成后，您将负责删除该对象。</p>
<h1 id="8-Accessing-Members-of-Stack-and-Heap-Objects"><a href="#8-Accessing-Members-of-Stack-and-Heap-Objects" class="headerlink" title="8.Accessing Members of Stack and Heap Objects"></a>8.Accessing Members of Stack and Heap Objects</h1><p>你已经看到可以在堆或C ++中的栈上创建对象。 但是，在使用每种类型时，有一个微妙但重要的区别：访问成员变量和成员函数的方式略有不同。</p>
<p>使用栈对象（stack objects）时，需要使用点运算符（<code>.</code>）, 使用堆对象（ heap objects），你需要使用箭头运算符（ <code>-&gt;</code>）解引用，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Person stackPerson;</div><div class="line">stackPerson.name = “Bob Smith”; ///&lt; Setting a member variable</div><div class="line">stackPerson.doSomething(); ///&lt; Calling a member function</div><div class="line"></div><div class="line">Person *heapPerson = new Person();</div><div class="line">heapPerson-&gt;name = “Bob Smith”; ///&lt; Setting a member variable</div><div class="line">heapPerson-&gt;doSomething(); ///&lt; Calling a member function</div></pre></td></tr></table></figure>
<p>虽然是微小差异，但还是应该引起你的注意！</p>
<p>你还将看到，与<code>this</code>指针一起使用的箭头运算符; 它与Objective-C中的<code>self</code>指针是一样的，并且在类成员函数中用于访问当前对象。</p>
<p>以下C ++示例显示了arrow运算符的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Person::doSomething() &#123;</div><div class="line">    this-&gt;doSomethingElse();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Objective-C中，如果你在一个nil指针上调用一个方法，你的应用程序仍然运行正常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myPerson = nil;</div><div class="line">[myPerson doSomething]; // does nothing</div></pre></td></tr></table></figure>
<p>但是，在C ++中，如果您尝试调用方法或访问NULL指针上的实例变量，则应用程序将崩溃：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myPerson = NULL;</div><div class="line">myPerson-&gt;doSomething(); // crash!</div></pre></td></tr></table></figure>
<p>因此，你在使用C++中必须非常小心，以确保不要尝试对NULL指针进行操作。</p>
<h1 id="9-References"><a href="#9-References" class="headerlink" title="9.References"></a>9.References</h1><p>当你将一个obejct传递给一个函数时，你传递一个obejct的副本，而不是obejct本身。 例如，考虑下面的C ++代码块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void changeValue(int x) &#123;</div><div class="line">    x = 5;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// …</div><div class="line"></div><div class="line">int x = 1;</div><div class="line">changeValue(x);</div><div class="line">// x still equals 1</div></pre></td></tr></table></figure>
<p>这是非常简单的，并不奇怪。 但是看看，当使用将对象作为参数的函数，做同样的事情时会发生什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Foo &#123;</div><div class="line">  public:</div><div class="line">    int x;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">void changeValue(Foo foo) &#123;</div><div class="line">    foo.x = 5;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// …</div><div class="line"></div><div class="line">Foo foo;</div><div class="line">foo.x = 1;</div><div class="line">changeValue(foo);</div><div class="line">// foo.x still equals 1</div></pre></td></tr></table></figure></p>
<p>也许这更让你惊讶。 如果你想到，传递给函数的参数是对象的副本的话，这就与参数是简单的int情况没有什么不同。</p>
<p>有时候，你确实想传递实际的对象。 一种方法是更改函数以获取对象的指针，而不是对象本身。 但是，当您调用该函数时，它会添加额外的代码。</p>
<p>C++添加了一个新的概念，允许你“通过引用”（by reference）传递变量。 这意味着没有复制; 这与上述“通过值”（by value）传递的例子形成对比。</p>
<p>通过引用改变你的调用是很简单的; 你只需使用地址运算符，即在函数签名中的变量前添加一个＆符号（＆），如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void changeValue(Foo &amp;foo) &#123;</div><div class="line">    foo.x = 5;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// …</div><div class="line"></div><div class="line">Foo foo;</div><div class="line">foo.x = 1;</div><div class="line">changeValue(foo);</div><div class="line">// foo.x equals 5</div></pre></td></tr></table></figure>
<p>它也适用于非类变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void changeValue(int &amp;x) &#123;</div><div class="line">    x = 5;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// …</div><div class="line"></div><div class="line">int x = 1;</div><div class="line">changeValue(x);</div><div class="line">// x equals 5</div></pre></td></tr></table></figure>
<p>通过引用传参非常有用，可以显着提高性能，有时候，获取对象的副本成本非常高。</p>
<h1 id="10-Inheritance"><a href="#10-Inheritance" class="headerlink" title="10.Inheritance"></a>10.Inheritance</h1><p>继承是面向对象语言的特性， 考如下两个Objective-C类，其中一个继承自另一个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@interface Person : NSObject</div><div class="line">@end</div><div class="line"></div><div class="line">@interface Employee : Person</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>C++中对继承也有相似的表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Person &#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class Employee : public Person &#123;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>C ++的唯一区别是添加<code>public</code>关键字。 在这里，<code>Employee</code>从<code>Person</code>继承，这意味着<code>Person</code>中的public属性的成员变量在<code>Employee</code>中保持public。</p>
<p>如果你用<strong>private</strong>替换<strong>public</strong>，那么Person的公共成员将在Employee中变为私有的。 有关此主题的更多信息，建议阅读<a href="http://www.learncpp.com/cpp-tutorial/115-inheritance-and-access-specifiers/" target="_blank" rel="external">inheritance and access specifiers here.</a>。</p>
<p>这是继承的基础部分，C ++与Objective-C不同之处在于它允许多重继承（<strong>multiple inheritance</strong>）。 这允许类从两个或更多个基类继承。 这可能对你来说似乎是陌生的，特别是如果你没有使用Objective-C以外的语言。这儿有一个多继承的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Player &#123;</div><div class="line">    void play();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class Manager &#123;</div><div class="line">    void manage();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class PlayerManager : public Player, public Manager &#123;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在这个例子中，有两个基类和一个继承自它们的类。 这意味着<code>PlayerManager</code>可以访问每个基类的所有成员变量和函数。呃，我确定你很痛苦地意识到，Objective-C无法做到这一点。</p>
<p>细心的读者会注意到Objective-C中有类似的东西：<code>protocol</code>。 尽管与多重继承不完全相同，但是这两种技术都旨在解决相同的问题：<strong>提供一种将几个类链接在一起的机制</strong>。</p>
<p><code>protocol</code>略有不同，因为它没有实现; 相反，它只是描述类的接口应该遵循的规范。</p>
<p>在Objective-C中，上面的例子可以写成如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@protocol Player</div><div class="line">- (void)play;</div><div class="line">@end</div><div class="line"></div><div class="line">@protocol Manager</div><div class="line">- (void)manage;</div><div class="line">@end</div><div class="line"></div><div class="line">@interface Player : NSObject &lt;Player&gt;</div><div class="line">@end</div><div class="line"></div><div class="line">@interface Manager : NSObject &lt;Manager&gt;</div><div class="line">@end</div><div class="line"></div><div class="line">@interface PlayerManager : NSObject &lt;Player, Manager&gt;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>当然，这是非常轻微的设计，但你得到的照片。 在Objective-C中，您必须在PlayerManager类中实现播放和管理，而在C++中，您将仅在每个基类中实现该方法，然后PlayerManager类将自动继承每个实现。</p>
<p>实际上，多重继承有时会导致混乱和复杂化。 在C++开发人员中经常被认为是一个危险的工具，除非绝对必要，否则不惜一切代价避免。</p>
<p>为什么？ 考虑如果两个基类实现了一个具有相同名称并且接受相同参数的函数 - 即两者都将具有相同的原型，那可能会发生什么? 在这种情况下，您需要一种消除歧义的方法。 例如，假设Player和Manager类都有一个名为foo的函数。</p>
<p>你需要消除歧义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PlayerManager p;</div><div class="line">p.foo();          ///&lt; Error! Which foo?</div><div class="line">p.Player::foo();  ///&lt; Call foo from Player</div><div class="line">p.Manager::foo(); ///&lt; Call foo from Manager</div></pre></td></tr></table></figure>
<p>这当然是可行的，但它增加了混乱和一层复杂性，这是最好的避免。 该决定取决于PlayerManager的用户。 使用协议留给PlayerManager类实现foo，所以只有一个实现 ，不会产生歧义。</p>
<h1 id="11-Where-to-Go-From-Here"><a href="#11-Where-to-Go-From-Here" class="headerlink" title="11.Where to Go From Here?"></a>11.Where to Go From Here?</h1><p>在本系列的第一部分，您学习了C ++的简史，如何声明一个类以及内存管理如何在C ++中运行。 当然还有比这更多的语言！</p>
<p>在本系列的<a href="https://www.raywenderlich.com/62989/introduction-c-ios-developers-part-1" target="_blank" rel="external">第二部分</a>，您将在了解标准库和Objective-C++之前，先了解更多高级类的功能和模板。</p>
<p>在此期间，如果您对C ++的冒险有任何问题或意见，请加入下面的讨论！</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Objective-C/" rel="tag"># Objective-C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/08/14/SDK开发实践01：开篇/" rel="next" title="SDK开发实践01：开篇">
                <i class="fa fa-chevron-left"></i> SDK开发实践01：开篇
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/08/15/iOS音视频处理02-获取视频流/" rel="prev" title="iOS音视频处理02-获取视频流">
                iOS音视频处理02-获取视频流 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://www.vstou.com/upload/image/355/201606/1465004143320282.jpg"
               alt="tank" />
          <p class="site-author-name" itemprop="name">tank</p>
           
              <p class="site-description motion-element" itemprop="description">大道理很多人都懂，为何脱颖而出的就那么几个人，因为他们不只懂而且也去做了。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Getting-Started-A-Brief-History-of-Languages"><span class="nav-number">1.</span> <span class="nav-text">1. Getting Started: A Brief History of Languages</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-C-Classes"><span class="nav-number">2.</span> <span class="nav-text">2.C++ Classes﻿</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-Class-Member-Variables-and-Functions"><span class="nav-number">3.</span> <span class="nav-text">3.Class Member Variables and Functions</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-Implementing-Class-Member-Functions"><span class="nav-number">4.</span> <span class="nav-text">4.Implementing Class Member Functions</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-Namespaces"><span class="nav-number">5.</span> <span class="nav-text">5.Namespaces</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-Memory-Management"><span class="nav-number">6.</span> <span class="nav-text">6.Memory Management</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-C-new-and-delete"><span class="nav-number">7.</span> <span class="nav-text">7.C++ new and delete</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-Accessing-Members-of-Stack-and-Heap-Objects"><span class="nav-number">8.</span> <span class="nav-text">8.Accessing Members of Stack and Heap Objects</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-References"><span class="nav-number">9.</span> <span class="nav-text">9.References</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-Inheritance"><span class="nav-number">10.</span> <span class="nav-text">10.Inheritance</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-Where-to-Go-From-Here"><span class="nav-number">11.</span> <span class="nav-text">11.Where to Go From Here?</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tank</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
