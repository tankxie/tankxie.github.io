<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="大道理很多人都懂，为何脱颖而出的就那么几个人，因为他们不只懂而且也去做了。">
<meta property="og:type" content="website">
<meta property="og:title" content="tankxie&#39;s blogs">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="tankxie&#39;s blogs">
<meta property="og:description" content="大道理很多人都懂，为何脱颖而出的就那么几个人，因为他们不只懂而且也去做了。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="tankxie&#39;s blogs">
<meta name="twitter:description" content="大道理很多人都懂，为何脱颖而出的就那么几个人，因为他们不只懂而且也去做了。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>tankxie's blogs</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">tankxie's blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/14/SDK开发实践01：开篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tank">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://www.vstou.com/upload/image/355/201606/1465004143320282.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tankxie's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/14/SDK开发实践01：开篇/" itemprop="url">SDK开发实践01：开篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-14T21:16:34+08:00">
                2017-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SDK开发/" itemprop="url" rel="index">
                    <span itemprop="name">SDK开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iOS native小组在SDK输出这条路上摸爬滚打一年多了，可披荆斩棘，写个文档mark一下，以飨来者，也欢迎大牛交流指点。</p>
<h2 id="文档结构"><a href="#文档结构" class="headerlink" title="文档结构"></a>文档结构</h2><p>iOS SDK开发实践系列计划写6篇：</p>
<ol>
<li>iOS SDK开发实践01：开篇</li>
<li>iOS SDK开发实践02：SDK接口设计原则，如何处理SDK中的依赖</li>
<li>iOS SDK开发实践03：cocopods私有库管理代码、打包</li>
<li>iOS SDK开发实践04：fastlane自动化实践</li>
<li>iOS SDK开发实践05：容易踩的坑</li>
</ol>
<p>##结语<br>实践过程凝结了无数人的汗水，@adamschen、@brownfeng、@danecai。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/14/【译】Introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tank">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://www.vstou.com/upload/image/355/201606/1465004143320282.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tankxie's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/14/【译】Introduction/" itemprop="url">【译】Introduction</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-14T21:12:43+08:00">
                2017-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文翻译自<a href="https://www.raywenderlich.com/62989/introduction-c-ios-developers-part-1" target="_blank" rel="external">Introduction to C++ for iOS Developers: Part 1﻿</a></p>
<p>如果你已经掌握了Objective-C了，正在寻找下一个很酷的东西去学习，尝试本篇文章吧，本篇文章为iOS开发者介绍C++。</p>
<p>正如我稍后解释，Objective-C、C和C ++代码能无缝协调工作。 因此，对于iOS开发人员来说，学习理解C ++有以下几个理由：</p>
<ul>
<li>有时你可能想要在APP中调用C ++编写的library。</li>
<li>你可能希望在C ++中编写应用程序的一部分代码，从而更容易跨平台移植。</li>
<li>掌握其他语言的良好基础，可以帮助你更好地了解编程。</li>
</ul>
<p>本文是针对已经了解Objective-C的iOS开发人员编写的。 假设你已经了解如何编写Objective-C代码，并熟悉C语言的基本概念，如类型，指针和函数。</p>
<p>准备好了么？接下来我们开始学习吧！</p>
<h1 id="1-Getting-Started-A-Brief-History-of-Languages"><a href="#1-Getting-Started-A-Brief-History-of-Languages" class="headerlink" title="1. Getting Started: A Brief History of Languages"></a>1. Getting Started: A Brief History of Languages</h1><p>C++和Objective-C同源：他们都来源于古老的C。这意味着它们都是C语言的“超集”（supersets）。 因此，在两种语言中，你可以使用C语言语法以及他们各自的特性。</p>
<p>如果你熟悉Objective-C，你可能对C ++代码有一个粗略的了解。 例如，诸如int，float和char之类标量类型的存在，并且在两种语言中的行为和表现方式完全相同。</p>
<p>Objective-C和C ++都将面向对象的功能添加到C。如果你还不熟悉“面向对象”这个术语，你需要了解的是，<strong>“面向对象”意味着数据通过对象表示，而对象又是类的实例</strong>。 事实上，C ++最初被称为“C with Classes”，它显示了使C++面向对象的基本愿望。</p>
<p>那么，你会问：“他们的差异在哪呢？”。 那么主要的区别就在面向对象特征的方式上（the approach to the object-oriented features）。 在C++中，很多操作在<strong>编译时</strong>发生，而在Objective-C中，<strong>运行时</strong>会发生更多的事情。 你可能已经使用Objective-C运行时来执行诸如方法转换（method swizzling）。 在C ++中，这根本就不可能。</p>
<p>C ++也没有Objective-C有过多的内省和反思方法（ <strong>introspection and reflection methods</strong>）。 没有办法像Objective-C那样在实例中简单地调用“类”方法来获取C++对象的类。 类似地，在C ++中没有等价于﻿<code>isMemberOfClass</code>﻿或<code>isKindOfClass</code>。</p>
<p>这是对C ++的粗略的介绍，显示了它与Obejctive-C之间的历史和主要区别。 下面开始继续介绍C++类。</p>
<p>#2.C++ Classes﻿<br>在任何面向对象语言中需要知道的第一件事是，如何定义一个类。 </p>
<p>在Objective-C中，创建一个头文件和一个实现文件来定﻿义一个类。 完全相同的事情发生在C ++中; 语法也很熟悉。<br>这是一个Objective-C类的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">MyClass.h</div><div class="line"></div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface MyClass : NSObject</div><div class="line">@end</div><div class="line"></div><div class="line">// MyClass.m</div><div class="line"></div><div class="line">#import “MyClass.h”</div><div class="line"></div><div class="line">@implementation MyClass</div><div class="line">@end﻿​</div></pre></td></tr></table></figure>
<p>对于iOS作为经验丰富的iOS开发人员来说，上述代码你是清楚的。 接下来看看C ++中的类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// MyClass.h</div><div class="line"></div><div class="line">class MyClass &#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// MyClass.cpp</div><div class="line"></div><div class="line">#include “MyClass.h”</div><div class="line"></div><div class="line">/* Nothing else in here */</div></pre></td></tr></table></figure>
<p>这里有一些明显的区别。 首先是C++中的实现文件没有任何内容，那是因为你没有在类上声明任何方法。 同样，空类也不需要像Objective-C那样的<code>@implemenation</code>/ <code>@end</code>块。</p>
<p>在Objective-C中，每个类几乎总是从<code>NSObject</code>继承。 你可以创建自己的根类，这意味着你的类不会有superclass，但是，除非你使用运行时（runtime），否则你不可能执行此操作。 这与C ++不同，在C++里，创建一个没有superclass的类是很常见的，如上例所示。</p>
<p>另一个微小的区别是<code>#include</code> vs. <code>#import</code>。 Objective-C将#import预处理程序指令添加到C。在C ++中没有等价物，因此使用标准C风格的#include。<strong> Objective-C的#import确保文件只包含一次，但在C++中，你必须自己执行此检查。</strong></p>
<p>#3.Class Member Variables and Functions<br>当然，一个类还有不仅仅只是声明它。 就像Objective-C一样，在C ++中，你可以向实例类添加实例变量（ <strong>instance variables</strong>）和方法（ <strong>methods</strong>）。你可能会听到他们在C ++中的不同定义; 它们通常被称为成员变量（<strong>member variables</strong>）和成员函数（<strong>member functions</strong>）。</p>
<blockquote>
<p>注意：术语“方法（methods）”并不真正用于C ++。 区别仅在Objective-C中，方法通过消息派发（message dispatch）调用。 另一方面，函数（function）是通过静态C风格的函数调用来调用的。 本文稍后将介绍静态与动态的更多内容。﻿</p>
</blockquote>
<p>那么，你如何声明成员变量和成员函数呢？ 那么这里有一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class MyClass &#123;</div><div class="line">    int x;</div><div class="line">    int y;</div><div class="line">    float z;</div><div class="line"></div><div class="line">    void foo();</div><div class="line">    void bar();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里有三个成员变量和两个成员函数。 </p>
<p>但是，在C++实际开发中你还可以进行更多操作，因为你可以限制C ++中的成员变量和成员函数的<strong>范围</strong>（scope），并将其声明为公开或私有可访问的。 这可以用来限制哪些代码可以访问每个变量或函数，示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class MyClass &#123;</div><div class="line">  public:</div><div class="line">    int x;</div><div class="line">    int y;</div><div class="line">    void foo();</div><div class="line"></div><div class="line">  private:</div><div class="line">    float z;</div><div class="line">    void bar();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里，x，y和foo是可公开访问的。这意味着它们可以在MyClass类之外使用。 但是，z和bar是私有的。 这意味着它们只能在MyClass内使用。 <strong>成员变量默认为私有</strong>。</p>
<p>虽然Objective-C中存在这种变量区分，但很少使用它。 另一方面，Objective-C不可能限制方法的范围。 即使你只在一个类的实现中声明一个方法，并且不将它暴露在接口中，你在技术上仍然可以从外部调用该方法。</p>
<p>Objective-C中的方法只有公开或仅仅按照惯例的私有（没有真正的私有）。 这就是为什么很多开发人员选择使用诸如“p_”之类的私有方法来表示区别。 这与C ++不同，如果您尝试从类外部调用私有方法，编译器将抛出错误。</p>
<p>那么你如何使用一个类？ 和Objective-C相似。 你创建一个这样的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">MyClass m;</div><div class="line">m.x = 10;</div><div class="line">m.y = 20;</div><div class="line">m.foo();</div></pre></td></tr></table></figure>
<p>就那么简单！ 这将创建一个MyClass的实例，将x和y分别设置为10和20，然后调用foo。</p>
<p>#4.Implementing Class Member Functions<br>你已经看到了如何定义一个类接口，但是如何实现函数呢？事实证明，这很简单。 有几种方法可以做到这一点。 的第一种实现方法是通过在类的实现文件 —- .cpp文件中定义它。 你可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//MyClass.h</div><div class="line">classMyClass&#123;</div><div class="line">intx;</div><div class="line">inty;</div><div class="line">voidfoo();</div><div class="line">&#125;;</div><div class="line">//MyClass.cpp</div><div class="line">#include“MyClass.h”</div><div class="line">MyClass::foo()&#123;</div><div class="line">//Dosomething</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是第一种方式 它与Objective-C中如何做到非常相似。 注意，使用<code>MyClass ::</code>; 这是你如何表示foo() 函数被实现为MyClass类的一部分。</p>
<p>实现方法的第二种方法是在Objective-C中不能做的事情。 在C ++中，你可以直接在头文件中实现一个方法，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//MyClass.h</div><div class="line">classMyClass&#123;</div><div class="line">intx;</div><div class="line">inty;</div><div class="line">voidfoo()&#123;</div><div class="line">//Dosomething</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果你仅使用过Objective-C，这可能对你来说看起来很奇怪。 这是相当奇怪的，但它也可以是非常有用的。 当以这种方式声明函数时，编译器可以执行称为“<strong>内联（inlining）</strong>”的优化。<strong> 这意味着当调用此函数时，而不是跳转到新的代码块，整个功能代码在调用处内联编译。</strong></p>
<p>虽然内联可以使代码更快，但它也会增加编译代码的大小，因为如果函数多次被调用，代码将在整个二进制文件中复制。 如果函数相当大或被调用了很多次，那么这可能会对二进制文件的大小产生重大影响。 这可能导致性能下降，因为较少的代码可以适应缓存，这意味着可能存在更多的高速缓存未命中。</p>
<p>我的目标是说明C ++允许很多的灵活性。 作为开发人员，你需要了解权衡并作出决定。 当然，唯一的方法是真正知道哪个选择适合你，就是调整你的代码！</p>
<p>#5.Namespaces<br>上面看到的示例介绍了一些你以前没有遇到的新语法 ， 双冒号 —-  <code>::</code>。 这是你如何在C ++中引用范围的; 以上使用它来告诉编译器应该在哪里查找foo函数。</p>
<p>另一次你会看到双冒号是使用命名空间。 命名空间是一种分离代码的方式，因此命名冲突不太可能发生。</p>
<p>例如，你可以在自己的代码中实现一个名为Person的类，但第三方库也可以实现一个名为Person的类。 因此，在编写C ++时，通常将所有代码放入命名空间中，以避免这些类型的命名冲突。</p>
<p>这很容易做到这一点 你只需用以下命名空间声明来包装所有内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">namespaceMyNamespace&#123;</div><div class="line">classPerson&#123;…&#125;;</div><div class="line">&#125;</div><div class="line">namespaceLibraryNamespace&#123;</div><div class="line">classPerson&#123;…&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，当使用Person类的任一实现时，可以使用双冒号来消除歧义，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MyNamespace::PersonpOne;</div><div class="line">LibraryNamespace::PersonpTwo;</div></pre></td></tr></table></figure>
<p>很简单，不是吗？<br>在Objective-C中没有等价的命名空间，只能在类的前面加前缀。</p>
<blockquote>
<p>注意：Objective-C中有几个命名空间的建议。 一个这样的建议可以在这里找到。 我不知道我们是否会在Objective-C中看到他们，但我确实希望如此！</p>
</blockquote>
<p>#6.Memory Management<br>Oh no…不是那个可怕的短语！ 内存管理是任何语言中最重要的事情之一。 Java基本上让垃圾收集器做它的工作。 Objective-C要求你了解引用计数（ reference counting）和ARC所扮演的角色。 在C ++中…好吧，C ++又是一个不同的野兽。</p>
<p>首先，要了解C ++中的内存管理，您真的需要了解<strong>栈</strong>（stack）和<strong>堆</strong>（heap）。 即使你认为你知道这一点，我建议你继续阅读; 你可能会学习以下两两点：</p>
<ul>
<li>stack是供正在运行的应用程序是用的内存块。 它是一个固定的大小，被应用程序的代码用于存储数据。 stack以push/pull为基础; 当给定的函数运行时，它将数据push到堆栈上，当函数完成时，它必须pull相同数量的数据。 因此，随着时间的推移，堆栈使用率将不会增长。</li>
<li>heap也是运行应用程序可用的内存块。 它的大小不固定，并随着应用程序的运行而增长。 应用程存储将“在函数范围之外使用的数据”存储在heap中。 而且，大型数据通常会存储在堆中，因为将其存储在堆栈中可能会溢出堆栈 。请记住，堆栈是固定的大小。</li>
</ul>
<p>这是堆栈和堆理论的一个很简单的概述; 这里有一些C代码显示了实践中的栈和堆：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">intstackInt=5;</div><div class="line">int*heapInt=malloc(sizeof(int));</div><div class="line">*heapInt=5;</div><div class="line">free(heapInt);</div></pre></td></tr></table></figure>
<p>这里，stackInt正在使用栈空间; 函数返回后，用于存储值“5”的内存将自动释放。</p>
<p>然而，heapInt正在使用堆空间。 对malloc的调用在堆上分配足够的空间来存储int变量。 但是，由于堆必须由开发人员进行管理，因此，在完成数据后，需要进行释放这一片堆空间，以确保不会泄漏内存。    </p>
<p>在Objective-C中，只能在堆上创建对象; 如果您尝试在栈上创建一个对象，则会收到编译器错误。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSStringstackString;</div><div class="line">//Untitled32.m:5:18:error:interfacetypecannotbestaticallyallocated</div><div class="line">//NSStringstackString;</div><div class="line">//^</div><div class="line">//*</div><div class="line">//1errorgenerated</div></pre></td></tr></table></figure></p>
<p>这就是为什么你会看到，全部Objective-C代码创建的对象，都带有星号; 所有对象都在堆上创建，并且返回指向这些对象的指针。 这主要归结于Objective-C处理内存管理的方式。 对象需要在堆上，通过引用计数，使其生命周期得到严格的控制。</p>
<p>在C ++中，您可以决定将数据存储在堆栈或堆上; 选择取决于开发人员。 但是，在C ++中，必须自己管理内存。 存放在栈中的数据会自动进行处理，但是当你开始使用堆时，必须自己处理内存管理，处理不好有内存泄露的风险。</p>
<p>#7.C++ new and delete</p>
<p>C ++引入了几个关键字来帮助<strong>堆对象</strong>的内存管理; 它们用于创建和销毁堆上的对象。<br>创建对象是这样完成的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person *person = new Person();</div></pre></td></tr></table></figure>
<p>当你完成对象后，你可以像这样释放它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">delete person;</div></pre></td></tr></table></figure>
<p>实际上，这甚至适用于C ++中的标量类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int *x = new int();</div><div class="line">*x = 5;</div><div class="line">delete x;</div></pre></td></tr></table></figure>
<p>您可以将这些操作看作与Objective-C中对象初始化和销毁相同的操作。 在C ++中使用新的<code>Person（）</code>初始化，相当于Objective-C中的<code>[[Person alloc] init]</code>。</p>
<p>不过Objective-C中没有和<code>delete</code>等价的关键字。 我确定你知道，一个Objective-C对象的释放由运行时处理，当它的<strong>引用计数</strong>降到零时。 记住，C++不会为你引用计数。 完成后，您将负责删除该对象。</p>
<p>#8.Accessing Members of Stack and Heap Objects<br>你已经看到可以在堆或C ++中的栈上创建对象。 但是，在使用每种类型时，有一个微妙但重要的区别：访问成员变量和成员函数的方式略有不同。</p>
<p>使用栈对象（stack objects）时，需要使用点运算符（<code>.</code>）, 使用堆对象（ heap objects），你需要使用箭头运算符（ <code>-&gt;</code>）解引用，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Person stackPerson;</div><div class="line">stackPerson.name = “Bob Smith”; ///&lt; Setting a member variable</div><div class="line">stackPerson.doSomething(); ///&lt; Calling a member function</div><div class="line"></div><div class="line">Person *heapPerson = new Person();</div><div class="line">heapPerson-&gt;name = “Bob Smith”; ///&lt; Setting a member variable</div><div class="line">heapPerson-&gt;doSomething(); ///&lt; Calling a member function</div></pre></td></tr></table></figure>
<p>虽然是微小差异，但还是应该引起你的注意！</p>
<p>你还将看到，与<code>this</code>指针一起使用的箭头运算符; 它与Objective-C中的<code>self</code>指针是一样的，并且在类成员函数中用于访问当前对象。</p>
<p>以下C ++示例显示了arrow运算符的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Person::doSomething() &#123;</div><div class="line">    this-&gt;doSomethingElse();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Objective-C中，如果你在一个nil指针上调用一个方法，你的应用程序仍然运行正常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myPerson = nil;</div><div class="line">[myPerson doSomething]; // does nothing</div></pre></td></tr></table></figure>
<p>但是，在C ++中，如果您尝试调用方法或访问NULL指针上的实例变量，则应用程序将崩溃：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myPerson = NULL;</div><div class="line">myPerson-&gt;doSomething(); // crash!</div></pre></td></tr></table></figure>
<p>因此，你在使用C++中必须非常小心，以确保不要尝试对NULL指针进行操作。</p>
<p>#9.References<br>当你将一个obejct传递给一个函数时，你传递一个obejct的副本，而不是obejct本身。 例如，考虑下面的C ++代码块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void changeValue(int x) &#123;</div><div class="line">    x = 5;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// …</div><div class="line"></div><div class="line">int x = 1;</div><div class="line">changeValue(x);</div><div class="line">// x still equals 1</div></pre></td></tr></table></figure>
<p>这是非常简单的，并不奇怪。 但是看看，当使用将对象作为参数的函数，做同样的事情时会发生什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Foo &#123;</div><div class="line">  public:</div><div class="line">    int x;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">void changeValue(Foo foo) &#123;</div><div class="line">    foo.x = 5;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// …</div><div class="line"></div><div class="line">Foo foo;</div><div class="line">foo.x = 1;</div><div class="line">changeValue(foo);</div><div class="line">// foo.x still equals 1</div></pre></td></tr></table></figure></p>
<p>也许这更让你惊讶。 如果你想到，传递给函数的参数是对象的副本的话，这就与参数是简单的int情况没有什么不同。</p>
<p>有时候，你确实想传递实际的对象。 一种方法是更改函数以获取对象的指针，而不是对象本身。 但是，当您调用该函数时，它会添加额外的代码。</p>
<p>C++添加了一个新的概念，允许你“通过引用”（by reference）传递变量。 这意味着没有复制; 这与上述“通过值”（by value）传递的例子形成对比。</p>
<p>通过引用改变你的调用是很简单的; 你只需使用地址运算符，即在函数签名中的变量前添加一个＆符号（＆），如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void changeValue(Foo &amp;foo) &#123;</div><div class="line">    foo.x = 5;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// …</div><div class="line"></div><div class="line">Foo foo;</div><div class="line">foo.x = 1;</div><div class="line">changeValue(foo);</div><div class="line">// foo.x equals 5</div></pre></td></tr></table></figure>
<p>它也适用于非类变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void changeValue(int &amp;x) &#123;</div><div class="line">    x = 5;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// …</div><div class="line"></div><div class="line">int x = 1;</div><div class="line">changeValue(x);</div><div class="line">// x equals 5</div></pre></td></tr></table></figure>
<p>通过引用传参非常有用，可以显着提高性能，有时候，获取对象的副本成本非常高。</p>
<p>#10.Inheritance<br>继承是面向对象语言的特性， 考如下两个Objective-C类，其中一个继承自另一个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@interface Person : NSObject</div><div class="line">@end</div><div class="line"></div><div class="line">@interface Employee : Person</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>C++中对继承也有相似的表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Person &#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class Employee : public Person &#123;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>C ++的唯一区别是添加<code>public</code>关键字。 在这里，<code>Employee</code>从<code>Person</code>继承，这意味着<code>Person</code>中的public属性的成员变量在<code>Employee</code>中保持public。</p>
<p>如果你用<strong>private</strong>替换<strong>public</strong>，那么Person的公共成员将在Employee中变为私有的。 有关此主题的更多信息，建议阅读<a href="http://www.learncpp.com/cpp-tutorial/115-inheritance-and-access-specifiers/" target="_blank" rel="external">inheritance and access specifiers here.</a>。</p>
<p>这是继承的基础部分，C ++与Objective-C不同之处在于它允许多重继承（<strong>multiple inheritance</strong>）。 这允许类从两个或更多个基类继承。 这可能对你来说似乎是陌生的，特别是如果你没有使用Objective-C以外的语言。这儿有一个多继承的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Player &#123;</div><div class="line">    void play();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class Manager &#123;</div><div class="line">    void manage();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class PlayerManager : public Player, public Manager &#123;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在这个例子中，有两个基类和一个继承自它们的类。 这意味着<code>PlayerManager</code>可以访问每个基类的所有成员变量和函数。呃，我确定你很痛苦地意识到，Objective-C无法做到这一点。</p>
<p>细心的读者会注意到Objective-C中有类似的东西：<code>protocol</code>。 尽管与多重继承不完全相同，但是这两种技术都旨在解决相同的问题：<strong>提供一种将几个类链接在一起的机制</strong>。</p>
<p><code>protocol</code>略有不同，因为它没有实现; 相反，它只是描述类的接口应该遵循的规范。</p>
<p>在Objective-C中，上面的例子可以写成如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@protocol Player</div><div class="line">- (void)play;</div><div class="line">@end</div><div class="line"></div><div class="line">@protocol Manager</div><div class="line">- (void)manage;</div><div class="line">@end</div><div class="line"></div><div class="line">@interface Player : NSObject &lt;Player&gt;</div><div class="line">@end</div><div class="line"></div><div class="line">@interface Manager : NSObject &lt;Manager&gt;</div><div class="line">@end</div><div class="line"></div><div class="line">@interface PlayerManager : NSObject &lt;Player, Manager&gt;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>当然，这是非常轻微的设计，但你得到的照片。 在Objective-C中，您必须在PlayerManager类中实现播放和管理，而在C++中，您将仅在每个基类中实现该方法，然后PlayerManager类将自动继承每个实现。</p>
<p>实际上，多重继承有时会导致混乱和复杂化。 在C++开发人员中经常被认为是一个危险的工具，除非绝对必要，否则不惜一切代价避免。</p>
<p>为什么？ 考虑如果两个基类实现了一个具有相同名称并且接受相同参数的函数 - 即两者都将具有相同的原型，那可能会发生什么? 在这种情况下，您需要一种消除歧义的方法。 例如，假设Player和Manager类都有一个名为foo的函数。</p>
<p>你需要消除歧义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PlayerManager p;</div><div class="line">p.foo();          ///&lt; Error! Which foo?</div><div class="line">p.Player::foo();  ///&lt; Call foo from Player</div><div class="line">p.Manager::foo(); ///&lt; Call foo from Manager</div></pre></td></tr></table></figure>
<p>这当然是可行的，但它增加了混乱和一层复杂性，这是最好的避免。 该决定取决于PlayerManager的用户。 使用协议留给PlayerManager类实现foo，所以只有一个实现 ，不会产生歧义。</p>
<p>#11.Where to Go From Here?<br>在本系列的第一部分，您学习了C ++的简史，如何声明一个类以及内存管理如何在C ++中运行。 当然还有比这更多的语言！</p>
<p>在本系列的<a href="https://www.raywenderlich.com/62989/introduction-c-ios-developers-part-1" target="_blank" rel="external">第二部分</a>，您将在了解标准库和Objective-C++之前，先了解更多高级类的功能和模板。</p>
<p>在此期间，如果您对C ++的冒险有任何问题或意见，请加入下面的讨论！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/14/FFmpeg学习笔记01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tank">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://www.vstou.com/upload/image/355/201606/1465004143320282.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tankxie's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/14/FFmpeg学习笔记01/" itemprop="url">FFmpeg学习笔记01</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-14T18:52:18+08:00">
                2017-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FFMpeg学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">FFMpeg学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>学习新技术之前，问自己两个问题很重要：</p>
<ul>
<li>掌握这门需要学哪些方面的知识？</li>
<li>应用场景是什么？</li>
</ul>
<p>把这两个问题弄清楚之后，一方面可以从宏观上对知识形成体系；另一方面可以突出学习的主次。本文主要记录我当时学的时候，思考这两个问题时候的心路历程，整理出来供自己日后翻阅！</p>
<h2 id="学习背景"><a href="#学习背景" class="headerlink" title="学习背景"></a>学习背景</h2><ol>
<li>前段时间在做人脸识别和OCR项目的时候，需要在移动端录制视频传到后台进行检测或识别，这个过程首先要在移动端采集视频，然后将视频数据传递到后台做处理。</li>
<li>音视频技术在移动端应用日益广泛，应用场景很丰富。</li>
</ol>
<p>##应用场景</p>
<p>音视频处理和我们并不陌生。</p>
<p>打电话、微信语音聊天、在各种直播平台上看直播、用微信视频聊天等行为，都是我们每天都在经历。从这个意义上讲，音视频处理对我们而言并不陌生。</p>
<p>在上述列举的场景中，我们可以提取出一个玩音视频通用的模型：</p>
<p><strong>A处采集</strong> –&gt; <strong>传输</strong> –&gt; <strong>B处播放</strong>。</p>
<p>这三个步骤是普通用户是可以感知的，但其实，还有步骤是向普通用户隐藏的。</p>
<p>由于采集的音视频原始数据太大，我们采集完之后并不会立即传输，而是会<strong>编码</strong>后进行传输；同样，用户接收到网络传输的数据之后需要<strong>解码</strong>之后才能播放。所以，实际的流程是这样的：</p>
<p>A处采集 –&gt; <strong>编码</strong> –&gt; 传输 –&gt; <strong>解码</strong> –&gt; B处播放。</p>
<p>大致知道是怎么玩的之后，我们就可以分析其中包含的技术点了，然后在其中去找你最迫切需要的技术去学习。</p>
<h2 id="音视频处理基本流程"><a href="#音视频处理基本流程" class="headerlink" title="音视频处理基本流程"></a>音视频处理基本流程</h2><p>接下来看一下，音频采集、编码、传输、解码以及播放的流程。</p>
<p><img src="/2017/08/14/FFmpeg学习笔记01/音频处理流程.png" alt="音频采集、传输播放模型"><br>从上图我们可以总结出：</p>
<ol>
<li>硬件设备采集的原始音频数据是PCM格式数据，原始数据有很多冗余，体积大，并不适合传输，因此，我们要对它进行编码，采集这一块与我而言不是重点，在这就一笔带过；</li>
<li>编码就是压缩数据的一个过程，图示的是采用G711编码算法来编码PCM数据。编码有硬编码和软编码之分，编码算法也有多种，编码需要重点学习，后面有专门篇章介绍；</li>
<li>编码之后数据经过网络传输，这涉及到网络传输协议，这就涉及到各种流媒体传输网络协议，后面有专门篇章介绍；</li>
<li>接下来就走到解码和播放部分了，其实就是播放器，后续也有专门篇章介绍。</li>
</ol>
<p>视频亦然，如下图所示：</p>
<p><img src="/2017/08/14/FFmpeg学习笔记01/视频处理流程.png" alt="音频采集、传输播放模型"></p>
<p>今天只做流程介绍，这两张图后续有详细介绍！</p>
<h2 id="音视频基础知识框图"><a href="#音视频基础知识框图" class="headerlink" title="音视频基础知识框图"></a>音视频基础知识框图</h2><p>一下框图是从雷霄华学者的<a href="http://blog.csdn.net/leixiaohua1020/article/details/18893769" target="_blank" rel="external">博客</a>提取出来的，很全面，重新整理一下，分享一下，可以对照其中学习：</p>
<p><img src="/2017/08/14/FFmpeg学习笔记01/音视频学习框架.png" alt="音频采集、传输播放模型"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>弄清楚场景和知识体系之后，接下来就是找自己需要或者感兴趣的模块去学习了，just do it！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://www.vstou.com/upload/image/355/201606/1465004143320282.jpg"
               alt="tank" />
          <p class="site-author-name" itemprop="name">tank</p>
           
              <p class="site-description motion-element" itemprop="description">大道理很多人都懂，为何脱颖而出的就那么几个人，因为他们不只懂而且也去做了。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tank</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
