<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="大道理很多人都懂，为何脱颖而出的就那么几个人，因为他们不只懂而且也去做了。">
<meta property="og:type" content="website">
<meta property="og:title" content="tankxie&#39;s blogs">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="tankxie&#39;s blogs">
<meta property="og:description" content="大道理很多人都懂，为何脱颖而出的就那么几个人，因为他们不只懂而且也去做了。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="tankxie&#39;s blogs">
<meta name="twitter:description" content="大道理很多人都懂，为何脱颖而出的就那么几个人，因为他们不只懂而且也去做了。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>tankxie's blogs</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">tankxie's blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/02/Swift/Swift学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tank">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://www.vstou.com/upload/image/355/201606/1465004143320282.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tankxie's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/02/Swift/Swift学习笔记/" itemprop="url">Swift学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-02T23:56:37+08:00">
                2018-02-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/02/Swift/Swift学习笔记-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tank">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://www.vstou.com/upload/image/355/201606/1465004143320282.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tankxie's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/02/Swift/Swift学习笔记-1/" itemprop="url">Swift学习笔记-1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-02T23:56:37+08:00">
                2018-02-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/21/接下来一个时间段的规划/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tank">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://www.vstou.com/upload/image/355/201606/1465004143320282.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tankxie's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/21/接下来一个时间段的规划/" itemprop="url">接下来一个时间段的规划</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-21T00:44:29+08:00">
                2017-10-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="接下来一段时间的规划"><a href="#接下来一段时间的规划" class="headerlink" title="接下来一段时间的规划"></a>接下来一段时间的规划</h2><blockquote>
<p>晚上想想千条路，早上醒来走老路！</p>
<p>我，iOS程序员，正式毕业一年，入行两年，经历了三个东家。工作上感觉上可以做到轻松应付，没有了之前刚入行时的焦虑和兴奋，激情也感觉在丝丝退却。感觉自己正在慢慢的走进自己心理的“舒适区”，我过早的变成了一个“老司机”，这让我很矛盾。</p>
<p>一方面，想通过闲暇时间给自己充电，让自己进步；但残酷的现实是，这段时间心血来潮学了一下swift，swift刚学一周，又发现音视频处理很好玩，于是又去捣鼓音视频去了，学音视频刚学不久，又去玩AR去了…</p>
<p>于是一个月过去了，回头望去，每件事儿都只是开了个头，然后就没有然后了！！！</p>
<p>这是一个恶性循环，长此以往，你会质疑自己，因为你尝试过很多东西，结果一件事都没有坚持下来，你会沮丧，你会对自己失去信心</p>
<p>这种“太想进步”的想法和“什么都想学以及什么都没有学会”的结果，构成你内心的主要矛盾，每天折磨着你，让你焦躁，失眠，对自己绝望！</p>
<p>恐怖！！！我已经开始失眠了。</p>
<p>我当然不能走在这样的路上，所以我趁着失眠，夜深人静的时候，直面内心，做做心理功课，走出这个恶性循环！</p>
</blockquote>
<h2 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h2><p>出现这个问题的根源是<strong>缺乏清晰的目标</strong>，以及<strong>实现这个目标的方案</strong>！为了弄清楚这两个事儿，问自己几个问题：</p>
<ol>
<li>自己是个什么样的人？天赋型还是勤奋型？ （勤奋型）</li>
<li>自己的目标是什么？（做一名擅长音视频以及VR的终端开发工程师）</li>
<li>自己当前技术水平处于什么阶段？入门级？初级？中级？高级？（初级）</li>
<li>自己坚持学下去的动力是什么？（通过技术实现出一个东西的喜悦和满足感，喜欢写代码）</li>
<li>自己需要学的东西是什么？优先级和依赖关系是怎样的？怎么学？</li>
</ol>
<p>前三道题的答案我写在了后面括号里面，接下来就解决第四个问题。</p>
<h2 id="学什么"><a href="#学什么" class="headerlink" title="学什么"></a>学什么</h2><p>排名分先后，按照优先级来罗列吧。</p>
<h3 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h3><p>包括计算机网络、算法、编译在内的一系列理论知识！</p>
<p>和练武功一样，这些东西是内功心法，是基础！</p>
<h3 id="C-C-amp-amp-obj-c的高级特性"><a href="#C-C-amp-amp-obj-c的高级特性" class="headerlink" title="C/C++ &amp;&amp; obj-c的高级特性"></a>C/C++ &amp;&amp; obj-c的高级特性</h3><ul>
<li>runtime</li>
<li>内存机制</li>
<li>动画</li>
<li>OpenGL</li>
</ul>
<h3 id="重构自己写过的代码，性能检测与优化"><a href="#重构自己写过的代码，性能检测与优化" class="headerlink" title="重构自己写过的代码，性能检测与优化"></a>重构自己写过的代码，性能检测与优化</h3><h3 id="swift"><a href="#swift" class="headerlink" title="swift"></a>swift</h3><h3 id="音视频-amp-amp-AR"><a href="#音视频-amp-amp-AR" class="headerlink" title="音视频 &amp;&amp; AR"></a>音视频 &amp;&amp; AR</h3><h3 id="写技术博客"><a href="#写技术博客" class="headerlink" title="写技术博客"></a>写技术博客</h3><h3 id="学Java，清楚Android端怎么弄的"><a href="#学Java，清楚Android端怎么弄的" class="headerlink" title="学Java，清楚Android端怎么弄的"></a>学Java，清楚Android端怎么弄的</h3><h2 id="怎么学"><a href="#怎么学" class="headerlink" title="怎么学"></a>怎么学</h2><h3 id="辅助工具"><a href="#辅助工具" class="headerlink" title="辅助工具"></a>辅助工具</h3><h3 id="学习动力、自我约束和反馈机制"><a href="#学习动力、自我约束和反馈机制" class="headerlink" title="学习动力、自我约束和反馈机制"></a>学习动力、自我约束和反馈机制</h3><h3 id="写代码、看代码、重构代码、写文档、看书怎么分配"><a href="#写代码、看代码、重构代码、写文档、看书怎么分配" class="headerlink" title="写代码、看代码、重构代码、写文档、看书怎么分配"></a>写代码、看代码、重构代码、写文档、看书怎么分配</h3><h3 id="哪个时间段做什么事儿效率最高？"><a href="#哪个时间段做什么事儿效率最高？" class="headerlink" title="哪个时间段做什么事儿效率最高？"></a>哪个时间段做什么事儿效率最高？</h3><h3 id="长期规划"><a href="#长期规划" class="headerlink" title="长期规划"></a>长期规划</h3><h3 id="学习计划（短期）"><a href="#学习计划（短期）" class="headerlink" title="学习计划（短期）"></a>学习计划（短期）</h3><h3 id="如何结合好工作和自己的学习？"><a href="#如何结合好工作和自己的学习？" class="headerlink" title="如何结合好工作和自己的学习？"></a>如何结合好工作和自己的学习？</h3><h3 id="如何保持良好的心态"><a href="#如何保持良好的心态" class="headerlink" title="如何保持良好的心态"></a>如何保持良好的心态</h3><h3 id="除了学习写代码-我还应该做些什么？"><a href="#除了学习写代码-我还应该做些什么？" class="headerlink" title="除了学习写代码  我还应该做些什么？"></a>除了学习写代码  我还应该做些什么？</h3><p>##规划</p>
<h3 id="优化当前手上的sdk，需要做什么优化就学什么"><a href="#优化当前手上的sdk，需要做什么优化就学什么" class="headerlink" title="优化当前手上的sdk，需要做什么优化就学什么"></a>优化当前手上的sdk，需要做什么优化就学什么</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/15/开发笔记/手误引发的内存泄漏bug分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tank">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://www.vstou.com/upload/image/355/201606/1465004143320282.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tankxie's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/15/开发笔记/手误引发的内存泄漏bug分析/" itemprop="url">手误引发的内存泄漏bug分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-15T22:29:03+08:00">
                2017-10-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>描述：项目中的view controller B在执行pop操作之后回到view controller A，但是B没有释放，导致再次进入B页面的时候会出现一些异常，如下图所示。</p>
</blockquote>
<p><img src="/2017/10/15/开发笔记/手误引发的内存泄漏bug分析/1.jpg" alt="情况介绍"></p>
<h2 id="1-review源码"><a href="#1-review源码" class="headerlink" title="1. review源码"></a>1. review源码</h2><p>review A viewcontroller 中的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic,strong)WBOCRRecViewController *recVC;</div><div class="line"></div><div class="line">- (void)pushCameraToUpperSide:(BOOL)isUpper&#123;</div><div class="line">    // ...   </div><div class="line">    [self.navigationController pushViewController:self.recVC animated:YES];</div><div class="line">&#125;</div><div class="line">- (WBOCRRecViewController *)recVC&#123;</div><div class="line">    if (!_recVC) &#123;</div><div class="line">        _recVC = [[WBOCRRecViewController alloc]init];</div><div class="line">        _recVC.failedBlock = self.failedBlock;</div><div class="line">        _recVC.successBlock = self.successBlock;</div><div class="line">    &#125;</div><div class="line">    return _recVC;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>发现 A 持有了 B故从 B pop 到 A 的时候，不会释放 B，而业务逻辑是需要每次进入B的时候都初始化一次，那就改代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// @property (nonatomic,strong)WBOCRRecViewController *recVC;</div><div class="line"></div><div class="line">- (void)pushCameraToUpperSide:(BOOL)isUpper&#123;</div><div class="line">    WBOCRRecViewController *recVC = [[WBOCRRecViewController alloc]init];</div><div class="line">    [self.navigationController pushViewController:recVC animated:YES];</div><div class="line">&#125;</div><div class="line">//- (WBOCRRecViewController *)recVC&#123;</div><div class="line">//    if (!_recVC) &#123;</div><div class="line">//        _recVC = [[WBOCRRecViewController alloc]init];</div><div class="line">//        _recVC.failedBlock = self.failedBlock;</div><div class="line">//        _recVC.successBlock = self.successBlock;</div><div class="line">//    &#125;</div><div class="line">//    return _recVC;</div><div class="line">//&#125;</div></pre></td></tr></table></figure>
<p>重新run，额，还是不行，难道还有别的对象持有B？<br>由于B中代码的property比较多，前后写代码的时间跨度比较大，review时间成本较高，那就借助工具咯！！！</p>
<p>##2. 查看对象的实例之间的引用关系</p>
<p>run项目，进入目标页面，在Xcode的控制面板点击图示按钮</p>
<p><img src="/2017/10/15/开发笔记/手误引发的内存泄漏bug分析/2.jpg" alt="查看引用关系"></p>
<p>会出现如下页面，这些图示表示了引用情况</p>
<p><img src="/2017/10/15/开发笔记/手误引发的内存泄漏bug分析/3.jpg" alt="查看引用关系"></p>
<p>找到目标对象，由于我之前操作了两次（从A页面进入B，再推出到A操作），这里出现了两个B对象，可以肯定的是，代码发生了内存泄漏</p>
<p><img src="/2017/10/15/开发笔记/手误引发的内存泄漏bug分析/4.jpg" alt="查看引用关系"></p>
<p>点击任意一个B对象的实例进去查看详情，蓝色的块表示持有B的对象，桔色表示B，Quick look信息如下：</p>
<p><img src="/2017/10/15/开发笔记/手误引发的内存泄漏bug分析/6.jpg" alt="查看引用关系"><br><img src="/2017/10/15/开发笔记/手误引发的内存泄漏bug分析/5.jpg" alt="查看引用关系"></p>
<p>到这儿，找到了罪魁祸首！！！接下来就是回到代码中，查看代码</p>
<p>##3. 再review代码</p>
<p>查看代码，发现自己写了这么一段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@interface XXOCRStateManager : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, strong) id&lt;XXOCRStateProtocol&gt; delegate;</div><div class="line"></div><div class="line">// ...</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>犯了一个低级错误，用了<code>strong</code>,将strong修改为weak，问题解决了。</p>
<h2 id="4-顺藤摸瓜"><a href="#4-顺藤摸瓜" class="headerlink" title="4. 顺藤摸瓜"></a>4. 顺藤摸瓜</h2><p>开发中发现了一个问题，就是识别控制器上的view蒙层走不到<code>dealloc</code>方法里面去，重复“识别”、“退出识别”步骤，果不其然，系统内存留了多个maskview实例。那就是内存泄露了咯！</p>
<p>回溯代码，发现在识别控制器退出的时候写了这么一行代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.maskView = nil;</div></pre></td></tr></table></figure>
<p>很显然没能如愿以偿的释放maskview对象，下面介绍另一个内存泄漏检测的工具</p>
<h2 id="5-更好用的检测工具-MLeaksFinder"><a href="#5-更好用的检测工具-MLeaksFinder" class="headerlink" title="5. 更好用的检测工具 MLeaksFinder"></a>5. 更好用的检测工具 MLeaksFinder</h2><p><code>MLeaksFinder</code>是微信读书团队开源的一个内存检测工具，使用及其简单，把 MLeaksFinder 目录下的文件添加到你的项目中，就可以在运行时（debug 模式下）帮助你检测项目里的内存泄露了，无需修改任何业务逻辑代码，而且只在 debug 下开启，完全不影响你的 release 包，不污染代码</p>
<p>debug的时候，检测到代码内存泄漏后，console和界面上都会有输出提示，如下图</p>
<p><img src="/2017/10/15/开发笔记/手误引发的内存泄漏bug分析/7.png" alt="查看引用关系"></p>
<p><img src="/2017/10/15/开发笔记/手误引发的内存泄漏bug分析/8.png" alt="查看引用关系"></p>
<p>不难看出是由于timer导致的，回到代码中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)dealloc&#123;</div><div class="line">    NSLog(@&quot;mask view dealloc!!!&quot;);</div><div class="line">    [self.lineViewTimer invalidate];</div><div class="line">    self.lineViewTimer = nil;</div><div class="line">    [self removeObjectForNotification];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之前释放timer的方法写在dealloc方法里面，问题是没有release timer，就走不进dealloc方法里面去！！！</p>
<p>改进方法，增加一个releaseSource方法，在释放maskview对象之前调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)releaseSource&#123;</div><div class="line">    [self.lineViewTimer invalidate];</div><div class="line">    self.lineViewTimer = nil;</div><div class="line">    [self removeObjectForNotification];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[self.maskView releaseSource];</div><div class="line">self.maskView = nil;</div></pre></td></tr></table></figure>
<p>OK，重新run代码，终于，代码走进了dealloc方法里面！</p>
<h2 id="6-未完待续"><a href="#6-未完待续" class="headerlink" title="6.未完待续"></a>6.未完待续</h2><p>这记录了开发过程中遇到的一个内存泄漏的问题，简单记录了发现问题和解决问题的思路和方法，后续有时间了做一下原理层次的分析，总结经验，避免同样的坑踩多次！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/15/SDK/SDK性能优化-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tank">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://www.vstou.com/upload/image/355/201606/1465004143320282.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tankxie's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/15/SDK/SDK性能优化-1/" itemprop="url">SDK性能优化(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-15T14:58:42+08:00">
                2017-10-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SDK开发/" itemprop="url" rel="index">
                    <span itemprop="name">SDK开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="常见的内存泄露场景"><a href="#常见的内存泄露场景" class="headerlink" title="常见的内存泄露场景"></a>常见的内存泄露场景</h2><h2 id="内存泄露检测"><a href="#内存泄露检测" class="headerlink" title="内存泄露检测"></a>内存泄露检测</h2><blockquote>
<p>本文是在Xcode9.0下利用Instrument中的Leak工具完成。</p>
</blockquote>
<h3 id="1-使用instrument检测内存泄露"><a href="#1-使用instrument检测内存泄露" class="headerlink" title="1. 使用instrument检测内存泄露"></a>1. 使用instrument检测内存泄露</h3><p>点击 Xcode &gt; Product &gt; Profile</p>
<p><img src="/2017/10/15/SDK/SDK性能优化-1/1.png" alt="打开instrument"></p>
<p>等到项目编译完成之后，系统会打开instrument，如下图所示：</p>
<p><img src="/2017/10/15/SDK/SDK性能优化-1/2.jpg" alt="打开instrument"></p>
<p>选择leak，点击choose按钮，进入内存检测页面</p>
<p><img src="/2017/10/15/SDK/SDK性能优化-1/3.jpg" alt="打开instrument"></p>
<p>点击左上角的录制按钮，开始录制，在你的手机上，操作目标APP，若出现图示红块，表明检测到了内存泄露，为了方便定位内存泄露点，排除系统堆栈的干扰，按照图示操作</p>
<p><img src="/2017/10/15/SDK/SDK性能优化-1/4.jpg" alt="打开instrument"></p>
<p>点击泄露处的堆栈信息，跳转到发生泄露的代码处</p>
<p><img src="/2017/10/15/SDK/SDK性能优化-1/5.jpg" alt="打开instrument"></p>
<p><img src="/2017/10/15/SDK/SDK性能优化-1/6.jpg" alt="打开instrument"></p>
<p>分析代码，解决泄露问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CGRect imgRect = CGRectMake(0,0,CVPixelBufferGetWidth(pixelBuffer),                                            CVPixelBufferGetHeight(pixelBuffer));</div><div class="line">CGImageRef imgRef = [context createCGImage:ciImage fromRect:imgRect];</div><div class="line">UIImage *uiImage = [UIImage imageWithCGImage:imgRef];</div><div class="line">                [self.delegate preDetectedSucceed:uiImage];</div><div class="line">// 添加此行代码，释放imgRef             </div><div class="line">CGImageRelease(imgRef);</div></pre></td></tr></table></figure>
<p>重新编译代码，重复上述操作，此处内存泄露问题解决了</p>
<p>从上图不难看出，还有AFNetwork也出现了内存泄露，解决办法如下</p>
<p>这就是利用instrument来进行内存泄露检测的整个流程</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/17/SDK/SDK开发实践03：cocopods私有库管理代码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tank">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://www.vstou.com/upload/image/355/201606/1465004143320282.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tankxie's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/17/SDK/SDK开发实践03：cocopods私有库管理代码/" itemprop="url">SDK开发实践03：cocopods私有库管理代码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-17T19:01:03+08:00">
                2017-08-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SDK开发/" itemprop="url" rel="index">
                    <span itemprop="name">SDK开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文是这个系列文章的核心，本文会详细描述如何搭建cocopod私有库，提供一个step by step教程。</p>
</blockquote>
<p>本教程很多内容都是出自<a href="https://cocoapods.org/" target="_blank" rel="external">cocopods.org</a>，官网上东西也不是很多，建议有时间通读一下。</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>在使用和开发的过程中，会接触和使用一些关键的名词，这里做一个索引。</p>
<h1 id="什么是cocoapods"><a href="#什么是cocoapods" class="headerlink" title="什么是cocoapods"></a>什么是cocoapods</h1><p>官网上给的解释如下</p>
<blockquote>
<p>CocoaPods is a dependency manager for Swift and Objective-C Cocoa projects. It has over 36 thousand libraries and is used in over 2.4 million apps. CocoaPods can help you scale your projects elegantly.</p>
</blockquote>
<p>它是一个依赖管理（<strong>dependency manager</strong>）工具，可以很方便的帮你管理你项目的依赖。</p>
<p>如果你是新手，“依赖”可以理解为：别人已经写好的现成的代码块，你直接调用就好。而cocopods充当的角色就是，帮助你把你需要的代码块拉到你的项目中来。</p>
<p>是不是很炫酷！</p>
<h1 id="安装cocoapods"><a href="#安装cocoapods" class="headerlink" title="安装cocoapods"></a>安装cocoapods</h1><p>CocoaPods是用Ruby构建的，Ruby在Mac OS X上安装默认的。建议使用默认的Ruby安装。</p>
<p>使用默认的<code>Ruby</code>安装可能需要在安装gem时使用<code>sudo</code>。 有关安装说明请参考<a href="https://guides.cocoapods.org/using/getting-started.html#getting-started" target="_blank" rel="external">安装指南</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Xcode 7 + 8</div><div class="line">$ sudo gem install cocoapods</div></pre></td></tr></table></figure>
<h1 id="基础使用-–-使用cocopods公有库"><a href="#基础使用-–-使用cocopods公有库" class="headerlink" title="基础使用 – 使用cocopods公有库"></a>基础使用 – 使用cocopods公有库</h1><p>先讲一个使用示例，再讲原理！</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>假设我的项目中需要使用到<code>AFNetworking</code>、<code>ORStackView</code>以及<code>SwiftyJSON</code>三个开源库，现用cocopods来完成依赖。</p>
<p>这里我们新建一个名为<code>TKTestCocopods</code>测试工程，用来演示如何在项目中使用cocopods。项目路径以及目录结构如下:</p>
<p><img src="/2017/08/17/SDK/SDK开发实践03：cocopods私有库管理代码/2.png" alt=""></p>
<h3 id="创建Podfile"><a href="#创建Podfile" class="headerlink" title="创建Podfile"></a>创建Podfile</h3><p>在工程文件<code>TKTestCocopods.xcodeproj</code>目录下，创建名为<code>Podfile</code>的文本文件，这个文件你可以理解为一个清单，cocopods会按照这个清单去为你的项目添加依赖。内容如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">platform :ios, &apos;8.0&apos;</div><div class="line">use_frameworks!</div><div class="line"></div><div class="line">target &apos;TKTestCocopods&apos; do</div><div class="line">  pod &apos;AFNetworking&apos;, &apos;~&gt; 2.6&apos;</div><div class="line">  pod &apos;ORStackView&apos;, &apos;~&gt; 3.0&apos;</div><div class="line">  pod &apos;SwiftyJSON&apos;, &apos;~&gt; 2.3&apos;</div><div class="line">end</div></pre></td></tr></table></figure>
<p>目前你只要关注如下部分代码，这三句表明了<code>TKTestCocopods</code>z这个project所依赖库的名称和版本号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pod &apos;AFNetworking&apos;, &apos;~&gt; 2.6&apos;</div><div class="line">pod &apos;ORStackView&apos;, &apos;~&gt; 3.0&apos;</div><div class="line">pod &apos;SwiftyJSON&apos;, &apos;~&gt; 2.3&apos;</div></pre></td></tr></table></figure>
<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>其余部分代码后续讲解其含义，编辑完成之后，我们可以为我们的项目安装依赖库了，运行<code>pod install</code>命令了：</p>
<p><img src="/2017/08/17/SDK/SDK开发实践03：cocopods私有库管理代码/3.png" alt=""></p>
<p>安装完成之后，目录下的文件如下：</p>
<p><img src="/2017/08/17/SDK/SDK开发实践03：cocopods私有库管理代码/4.png" alt=""></p>
<p>打开<code>TKTestCocopods.xcworkspace</code>文件，项目目录结构如下：</p>
<p><img src="/2017/08/17/SDK/SDK开发实践03：cocopods私有库管理代码/5.png" alt=""></p>
<h3 id="使用依赖库"><a href="#使用依赖库" class="headerlink" title="使用依赖库"></a>使用依赖库</h3><p>此时，你可以在你项目中导入你需要的依赖库了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#import &lt;Reachability/Reachability.h&gt;</div></pre></td></tr></table></figure>
<h2 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h2><h3 id="pod-install究竟做了些什么？"><a href="#pod-install究竟做了些什么？" class="headerlink" title="pod install究竟做了些什么？"></a>pod install究竟做了些什么？</h3><p>我们再回过头看看我们执行<code>pod install</code>的时候，输出的log信息:<br><img src="/2017/08/17/SDK/SDK开发实践03：cocopods私有库管理代码/3.png" alt=""></p>
<p>把注意力集中在黄色文本信息上，我们不难发现，这条命令执行了如下五个操作：</p>
<ul>
<li><strong>Analyzing dependencies</strong>：分析依赖关系</li>
<li><strong>Downloading dependencies</strong>：下载依赖</li>
<li><strong>Generating Pods project</strong>：生成Pods工程</li>
<li><strong>Integrating client project</strong>：整合项目工程和Pods工程</li>
<li><strong>Sending stats</strong>：发送结果，此处是安装成功</li>
</ul>
<p>我们对install操作有了大致的了解，但还是不够详细，甚至有些疑惑。</p>
<p>比如：Podfile里面写了3个依赖文件，为什么按照的时候显示安装了4个依赖库，多出来的<code>FLKAutoLayout</code>从何而来？</p>
<p>此时就需要得到更详细的log信息了，查阅文档发现，几乎所有的pod命令都有一个可选参数<code>--verbose</code></p>
<p>verbose是“详细”之意，我们不难猜出，加上这个参数之后，我们可以看到更多的命令执行的log信息，此时运行<code>pod install --verbose</code>命令，此时输出了大量log，我们按照上面的分类来分别解读这些log信息。</p>
<h4 id="Analyzing-dependencies"><a href="#Analyzing-dependencies" class="headerlink" title="Analyzing dependencies"></a>Analyzing dependencies</h4><p><img src="/2017/08/17/SDK/SDK开发实践03：cocopods私有库管理代码/7.png" alt=""></p>
<p>这里面包含了4小步：</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/15/音视频/iOS音视频处理02-获取视频流/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tank">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://www.vstou.com/upload/image/355/201606/1465004143320282.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tankxie's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/15/音视频/iOS音视频处理02-获取视频流/" itemprop="url">iOS音视频处理02-获取视频流</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-15T21:21:26+08:00">
                2017-08-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/音视频学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">音视频学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>前言：本篇利用AVFoundation从摄像头获取视频数据。</p>
</blockquote>
<h2 id="从摄像头获取视频数据"><a href="#从摄像头获取视频数据" class="headerlink" title="从摄像头获取视频数据"></a>从摄像头获取视频数据</h2><p>iOS设备调用摄像头，获取视频数据的方式有两种：<code>UIImagePickerController</code>和<code>AVFoundation</code>，下面分析对比一下两种方式的优劣。</p>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h2 id="音视频基础知识"><a href="#音视频基础知识" class="headerlink" title="音视频基础知识"></a>音视频基础知识</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/14/音视频/iOS开发者需要了解的C++01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tank">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://www.vstou.com/upload/image/355/201606/1465004143320282.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tankxie's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/14/音视频/iOS开发者需要了解的C++01/" itemprop="url">iOS开发者需要了解的C++01</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-14T21:26:50+08:00">
                2017-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文翻译自<a href="https://www.raywenderlich.com/62989/introduction-c-ios-developers-part-1" target="_blank" rel="external">Introduction to C++ for iOS Developers: Part 1﻿</a></p>
<blockquote>
<p> 为了促使自己更认真的看文章，看完之后随手翻译了一把，里面有翻译不准的欢迎指正，看完之后，墙裂推荐，看一下原文！</p>
</blockquote>
<p>如果你已经掌握了Objective-C了，正在寻找下一个很酷的东西去学习，尝试本篇文章吧，本篇文章为iOS开发者介绍C++。</p>
<p>正如我稍后解释，Objective-C、C和C ++代码能无缝协调工作。 因此，对于iOS开发人员来说，学习理解C ++有以下几个理由：</p>
<ul>
<li>有时你可能想要在APP中调用C ++编写的library。</li>
<li>你可能希望在C ++中编写应用程序的一部分代码，从而更容易跨平台移植。</li>
<li>掌握其他语言的良好基础，可以帮助你更好地了解编程。</li>
</ul>
<p>本文是针对已经了解Objective-C的iOS开发人员编写的。 假设你已经了解如何编写Objective-C代码，并熟悉C语言的基本概念，如类型，指针和函数。</p>
<p>准备好了么？接下来我们开始学习吧！</p>
<h1 id="1-Getting-Started-A-Brief-History-of-Languages"><a href="#1-Getting-Started-A-Brief-History-of-Languages" class="headerlink" title="1. Getting Started: A Brief History of Languages"></a>1. Getting Started: A Brief History of Languages</h1><p>C++和Objective-C同源：他们都来源于古老的C。这意味着它们都是C语言的“超集”（supersets）。 因此，在两种语言中，你可以使用C语言语法以及他们各自的特性。</p>
<p>如果你熟悉Objective-C，你可能对C ++代码有一个粗略的了解。 例如，诸如int，float和char之类标量类型的存在，并且在两种语言中的行为和表现方式完全相同。</p>
<p>Objective-C和C ++都将面向对象的功能添加到C。如果你还不熟悉“面向对象”这个术语，你需要了解的是，<strong>“面向对象”意味着数据通过对象表示，而对象又是类的实例</strong>。 事实上，C ++最初被称为“C with Classes”，它显示了使C++面向对象的基本愿望。</p>
<p>那么，你会问：“他们的差异在哪呢？”。 那么主要的区别就在面向对象特征的方式上（the approach to the object-oriented features）。 在C++中，很多操作在<strong>编译时</strong>发生，而在Objective-C中，<strong>运行时</strong>会发生更多的事情。 你可能已经使用Objective-C运行时来执行诸如方法转换（method swizzling）。 在C ++中，这根本就不可能。</p>
<p>C ++也没有Objective-C有过多的内省和反思方法（ <strong>introspection and reflection methods</strong>）。 没有办法像Objective-C那样在实例中简单地调用“类”方法来获取C++对象的类。 类似地，在C ++中没有等价于﻿<code>isMemberOfClass</code>﻿或<code>isKindOfClass</code>。</p>
<p>这是对C ++的粗略的介绍，显示了它与Obejctive-C之间的历史和主要区别。 下面开始继续介绍C++类。</p>
<h1 id="2-C-Classes"><a href="#2-C-Classes" class="headerlink" title="2.C++ Classes﻿"></a>2.C++ Classes﻿</h1><p>在任何面向对象语言中需要知道的第一件事是，如何定义一个类。 </p>
<p>在Objective-C中，创建一个头文件和一个实现文件来定﻿义一个类。 完全相同的事情发生在C ++中; 语法也很熟悉。<br>这是一个Objective-C类的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">MyClass.h</div><div class="line"></div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface MyClass : NSObject</div><div class="line">@end</div><div class="line"></div><div class="line">// MyClass.m</div><div class="line"></div><div class="line">#import “MyClass.h”</div><div class="line"></div><div class="line">@implementation MyClass</div><div class="line">@end﻿​</div></pre></td></tr></table></figure>
<p>对于iOS作为经验丰富的iOS开发人员来说，上述代码你是清楚的。 接下来看看C ++中的类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// MyClass.h</div><div class="line"></div><div class="line">class MyClass &#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// MyClass.cpp</div><div class="line"></div><div class="line">#include “MyClass.h”</div><div class="line"></div><div class="line">/* Nothing else in here */</div></pre></td></tr></table></figure>
<p>这里有一些明显的区别。 首先是C++中的实现文件没有任何内容，那是因为你没有在类上声明任何方法。 同样，空类也不需要像Objective-C那样的<code>@implemenation</code>/ <code>@end</code>块。</p>
<p>在Objective-C中，每个类几乎总是从<code>NSObject</code>继承。 你可以创建自己的根类，这意味着你的类不会有superclass，但是，除非你使用运行时（runtime），否则你不可能执行此操作。 这与C ++不同，在C++里，创建一个没有superclass的类是很常见的，如上例所示。</p>
<p>另一个微小的区别是<code>#include</code> vs. <code>#import</code>。 Objective-C将#import预处理程序指令添加到C。在C ++中没有等价物，因此使用标准C风格的#include。<strong> Objective-C的#import确保文件只包含一次，但在C++中，你必须自己执行此检查。</strong></p>
<h1 id="3-Class-Member-Variables-and-Functions"><a href="#3-Class-Member-Variables-and-Functions" class="headerlink" title="3.Class Member Variables and Functions"></a>3.Class Member Variables and Functions</h1><p>当然，一个类还有不仅仅只是声明它。 就像Objective-C一样，在C ++中，你可以向实例类添加实例变量（ <strong>instance variables</strong>）和方法（ <strong>methods</strong>）。你可能会听到他们在C ++中的不同定义; 它们通常被称为成员变量（<strong>member variables</strong>）和成员函数（<strong>member functions</strong>）。</p>
<blockquote>
<p>注意：术语“方法（methods）”并不真正用于C ++。 区别仅在Objective-C中，方法通过消息派发（message dispatch）调用。 另一方面，函数（function）是通过静态C风格的函数调用来调用的。 本文稍后将介绍静态与动态的更多内容。﻿</p>
</blockquote>
<p>那么，你如何声明成员变量和成员函数呢？ 那么这里有一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class MyClass &#123;</div><div class="line">    int x;</div><div class="line">    int y;</div><div class="line">    float z;</div><div class="line"></div><div class="line">    void foo();</div><div class="line">    void bar();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里有三个成员变量和两个成员函数。 </p>
<p>但是，在C++实际开发中你还可以进行更多操作，因为你可以限制C ++中的成员变量和成员函数的<strong>范围</strong>（scope），并将其声明为公开或私有可访问的。 这可以用来限制哪些代码可以访问每个变量或函数，示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class MyClass &#123;</div><div class="line">  public:</div><div class="line">    int x;</div><div class="line">    int y;</div><div class="line">    void foo();</div><div class="line"></div><div class="line">  private:</div><div class="line">    float z;</div><div class="line">    void bar();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里，x，y和foo是可公开访问的。这意味着它们可以在MyClass类之外使用。 但是，z和bar是私有的。 这意味着它们只能在MyClass内使用。 <strong>成员变量默认为私有</strong>。</p>
<p>虽然Objective-C中存在这种变量区分，但很少使用它。 另一方面，Objective-C不可能限制方法的范围。 即使你只在一个类的实现中声明一个方法，并且不将它暴露在接口中，你在技术上仍然可以从外部调用该方法。</p>
<p>Objective-C中的方法只有公开或仅仅按照惯例的私有（没有真正的私有）。 这就是为什么很多开发人员选择使用诸如“p_”之类的私有方法来表示区别。 这与C ++不同，如果您尝试从类外部调用私有方法，编译器将抛出错误。</p>
<p>那么你如何使用一个类？ 和Objective-C相似。 你创建一个这样的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">MyClass m;</div><div class="line">m.x = 10;</div><div class="line">m.y = 20;</div><div class="line">m.foo();</div></pre></td></tr></table></figure>
<p>就那么简单！ 这将创建一个MyClass的实例，将x和y分别设置为10和20，然后调用foo。</p>
<h1 id="4-Implementing-Class-Member-Functions"><a href="#4-Implementing-Class-Member-Functions" class="headerlink" title="4.Implementing Class Member Functions"></a>4.Implementing Class Member Functions</h1><p>你已经看到了如何定义一个类接口，但是如何实现函数呢？事实证明，这很简单。 有几种方法可以做到这一点。 的第一种实现方法是通过在类的实现文件 —- .cpp文件中定义它。 你可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//MyClass.h</div><div class="line">classMyClass&#123;</div><div class="line">intx;</div><div class="line">inty;</div><div class="line">voidfoo();</div><div class="line">&#125;;</div><div class="line">//MyClass.cpp</div><div class="line">#include“MyClass.h”</div><div class="line">MyClass::foo()&#123;</div><div class="line">//Dosomething</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是第一种方式 它与Objective-C中如何做到非常相似。 注意，使用<code>MyClass ::</code>; 这是你如何表示foo() 函数被实现为MyClass类的一部分。</p>
<p>实现方法的第二种方法是在Objective-C中不能做的事情。 在C ++中，你可以直接在头文件中实现一个方法，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//MyClass.h</div><div class="line">classMyClass&#123;</div><div class="line">intx;</div><div class="line">inty;</div><div class="line">voidfoo()&#123;</div><div class="line">//Dosomething</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果你仅使用过Objective-C，这可能对你来说看起来很奇怪。 这是相当奇怪的，但它也可以是非常有用的。 当以这种方式声明函数时，编译器可以执行称为“<strong>内联（inlining）</strong>”的优化。<strong> 这意味着当调用此函数时，而不是跳转到新的代码块，整个功能代码在调用处内联编译。</strong></p>
<p>虽然内联可以使代码更快，但它也会增加编译代码的大小，因为如果函数多次被调用，代码将在整个二进制文件中复制。 如果函数相当大或被调用了很多次，那么这可能会对二进制文件的大小产生重大影响。 这可能导致性能下降，因为较少的代码可以适应缓存，这意味着可能存在更多的高速缓存未命中。</p>
<p>我的目标是说明C ++允许很多的灵活性。 作为开发人员，你需要了解权衡并作出决定。 当然，唯一的方法是真正知道哪个选择适合你，就是调整你的代码！</p>
<h1 id="5-Namespaces"><a href="#5-Namespaces" class="headerlink" title="5.Namespaces"></a>5.Namespaces</h1><p>上面看到的示例介绍了一些你以前没有遇到的新语法 ， 双冒号 —-  <code>::</code>。 这是你如何在C ++中引用范围的; 以上使用它来告诉编译器应该在哪里查找foo函数。</p>
<p>另一次你会看到双冒号是使用命名空间。 命名空间是一种分离代码的方式，因此命名冲突不太可能发生。</p>
<p>例如，你可以在自己的代码中实现一个名为Person的类，但第三方库也可以实现一个名为Person的类。 因此，在编写C ++时，通常将所有代码放入命名空间中，以避免这些类型的命名冲突。</p>
<p>这很容易做到这一点 你只需用以下命名空间声明来包装所有内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">namespaceMyNamespace&#123;</div><div class="line">classPerson&#123;…&#125;;</div><div class="line">&#125;</div><div class="line">namespaceLibraryNamespace&#123;</div><div class="line">classPerson&#123;…&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，当使用Person类的任一实现时，可以使用双冒号来消除歧义，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MyNamespace::PersonpOne;</div><div class="line">LibraryNamespace::PersonpTwo;</div></pre></td></tr></table></figure>
<p>很简单，不是吗？<br>在Objective-C中没有等价的命名空间，只能在类的前面加前缀。</p>
<blockquote>
<p>注意：Objective-C中有几个命名空间的建议。 一个这样的建议可以在这里找到。 我不知道我们是否会在Objective-C中看到他们，但我确实希望如此！</p>
</blockquote>
<h1 id="6-Memory-Management"><a href="#6-Memory-Management" class="headerlink" title="6.Memory Management"></a>6.Memory Management</h1><p>Oh no…不是那个可怕的短语！ 内存管理是任何语言中最重要的事情之一。 Java基本上让垃圾收集器做它的工作。 Objective-C要求你了解引用计数（ reference counting）和ARC所扮演的角色。 在C ++中…好吧，C ++又是一个不同的野兽。</p>
<p>首先，要了解C ++中的内存管理，您真的需要了解<strong>栈</strong>（stack）和<strong>堆</strong>（heap）。 即使你认为你知道这一点，我建议你继续阅读; 你可能会学习以下两两点：</p>
<ul>
<li>stack是供正在运行的应用程序是用的内存块。 它是一个固定的大小，被应用程序的代码用于存储数据。 stack以push/pull为基础; 当给定的函数运行时，它将数据push到堆栈上，当函数完成时，它必须pull相同数量的数据。 因此，随着时间的推移，堆栈使用率将不会增长。</li>
<li>heap也是运行应用程序可用的内存块。 它的大小不固定，并随着应用程序的运行而增长。 应用程存储将“在函数范围之外使用的数据”存储在heap中。 而且，大型数据通常会存储在堆中，因为将其存储在堆栈中可能会溢出堆栈 。请记住，堆栈是固定的大小。</li>
</ul>
<p>这是堆栈和堆理论的一个很简单的概述; 这里有一些C代码显示了实践中的栈和堆：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">intstackInt=5;</div><div class="line">int*heapInt=malloc(sizeof(int));</div><div class="line">*heapInt=5;</div><div class="line">free(heapInt);</div></pre></td></tr></table></figure>
<p>这里，stackInt正在使用栈空间; 函数返回后，用于存储值“5”的内存将自动释放。</p>
<p>然而，heapInt正在使用堆空间。 对malloc的调用在堆上分配足够的空间来存储int变量。 但是，由于堆必须由开发人员进行管理，因此，在完成数据后，需要进行释放这一片堆空间，以确保不会泄漏内存。    </p>
<p>在Objective-C中，只能在堆上创建对象; 如果您尝试在栈上创建一个对象，则会收到编译器错误。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSStringstackString;</div><div class="line">//Untitled32.m:5:18:error:interfacetypecannotbestaticallyallocated</div><div class="line">//NSStringstackString;</div><div class="line">//^</div><div class="line">//*</div><div class="line">//1errorgenerated</div></pre></td></tr></table></figure></p>
<p>这就是为什么你会看到，全部Objective-C代码创建的对象，都带有星号; 所有对象都在堆上创建，并且返回指向这些对象的指针。 这主要归结于Objective-C处理内存管理的方式。 对象需要在堆上，通过引用计数，使其生命周期得到严格的控制。</p>
<p>在C ++中，您可以决定将数据存储在堆栈或堆上; 选择取决于开发人员。 但是，在C ++中，必须自己管理内存。 存放在栈中的数据会自动进行处理，但是当你开始使用堆时，必须自己处理内存管理，处理不好有内存泄露的风险。</p>
<h1 id="7-C-new-and-delete"><a href="#7-C-new-and-delete" class="headerlink" title="7.C++ new and delete"></a>7.C++ new and delete</h1><p>C ++引入了几个关键字来帮助<strong>堆对象</strong>的内存管理; 它们用于创建和销毁堆上的对象。<br>创建对象是这样完成的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person *person = new Person();</div></pre></td></tr></table></figure>
<p>当你完成对象后，你可以像这样释放它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">delete person;</div></pre></td></tr></table></figure>
<p>实际上，这甚至适用于C ++中的标量类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int *x = new int();</div><div class="line">*x = 5;</div><div class="line">delete x;</div></pre></td></tr></table></figure>
<p>您可以将这些操作看作与Objective-C中对象初始化和销毁相同的操作。 在C ++中使用新的<code>Person（）</code>初始化，相当于Objective-C中的<code>[[Person alloc] init]</code>。</p>
<p>不过Objective-C中没有和<code>delete</code>等价的关键字。 我确定你知道，一个Objective-C对象的释放由运行时处理，当它的<strong>引用计数</strong>降到零时。 记住，C++不会为你引用计数。 完成后，您将负责删除该对象。</p>
<h1 id="8-Accessing-Members-of-Stack-and-Heap-Objects"><a href="#8-Accessing-Members-of-Stack-and-Heap-Objects" class="headerlink" title="8.Accessing Members of Stack and Heap Objects"></a>8.Accessing Members of Stack and Heap Objects</h1><p>你已经看到可以在堆或C ++中的栈上创建对象。 但是，在使用每种类型时，有一个微妙但重要的区别：访问成员变量和成员函数的方式略有不同。</p>
<p>使用栈对象（stack objects）时，需要使用点运算符（<code>.</code>）, 使用堆对象（ heap objects），你需要使用箭头运算符（ <code>-&gt;</code>）解引用，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Person stackPerson;</div><div class="line">stackPerson.name = “Bob Smith”; ///&lt; Setting a member variable</div><div class="line">stackPerson.doSomething(); ///&lt; Calling a member function</div><div class="line"></div><div class="line">Person *heapPerson = new Person();</div><div class="line">heapPerson-&gt;name = “Bob Smith”; ///&lt; Setting a member variable</div><div class="line">heapPerson-&gt;doSomething(); ///&lt; Calling a member function</div></pre></td></tr></table></figure>
<p>虽然是微小差异，但还是应该引起你的注意！</p>
<p>你还将看到，与<code>this</code>指针一起使用的箭头运算符; 它与Objective-C中的<code>self</code>指针是一样的，并且在类成员函数中用于访问当前对象。</p>
<p>以下C ++示例显示了arrow运算符的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Person::doSomething() &#123;</div><div class="line">    this-&gt;doSomethingElse();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Objective-C中，如果你在一个nil指针上调用一个方法，你的应用程序仍然运行正常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myPerson = nil;</div><div class="line">[myPerson doSomething]; // does nothing</div></pre></td></tr></table></figure>
<p>但是，在C ++中，如果您尝试调用方法或访问NULL指针上的实例变量，则应用程序将崩溃：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myPerson = NULL;</div><div class="line">myPerson-&gt;doSomething(); // crash!</div></pre></td></tr></table></figure>
<p>因此，你在使用C++中必须非常小心，以确保不要尝试对NULL指针进行操作。</p>
<h1 id="9-References"><a href="#9-References" class="headerlink" title="9.References"></a>9.References</h1><p>当你将一个obejct传递给一个函数时，你传递一个obejct的副本，而不是obejct本身。 例如，考虑下面的C ++代码块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void changeValue(int x) &#123;</div><div class="line">    x = 5;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// …</div><div class="line"></div><div class="line">int x = 1;</div><div class="line">changeValue(x);</div><div class="line">// x still equals 1</div></pre></td></tr></table></figure>
<p>这是非常简单的，并不奇怪。 但是看看，当使用将对象作为参数的函数，做同样的事情时会发生什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Foo &#123;</div><div class="line">  public:</div><div class="line">    int x;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">void changeValue(Foo foo) &#123;</div><div class="line">    foo.x = 5;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// …</div><div class="line"></div><div class="line">Foo foo;</div><div class="line">foo.x = 1;</div><div class="line">changeValue(foo);</div><div class="line">// foo.x still equals 1</div></pre></td></tr></table></figure></p>
<p>也许这更让你惊讶。 如果你想到，传递给函数的参数是对象的副本的话，这就与参数是简单的int情况没有什么不同。</p>
<p>有时候，你确实想传递实际的对象。 一种方法是更改函数以获取对象的指针，而不是对象本身。 但是，当您调用该函数时，它会添加额外的代码。</p>
<p>C++添加了一个新的概念，允许你“通过引用”（by reference）传递变量。 这意味着没有复制; 这与上述“通过值”（by value）传递的例子形成对比。</p>
<p>通过引用改变你的调用是很简单的; 你只需使用地址运算符，即在函数签名中的变量前添加一个＆符号（＆），如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void changeValue(Foo &amp;foo) &#123;</div><div class="line">    foo.x = 5;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// …</div><div class="line"></div><div class="line">Foo foo;</div><div class="line">foo.x = 1;</div><div class="line">changeValue(foo);</div><div class="line">// foo.x equals 5</div></pre></td></tr></table></figure>
<p>它也适用于非类变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void changeValue(int &amp;x) &#123;</div><div class="line">    x = 5;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// …</div><div class="line"></div><div class="line">int x = 1;</div><div class="line">changeValue(x);</div><div class="line">// x equals 5</div></pre></td></tr></table></figure>
<p>通过引用传参非常有用，可以显着提高性能，有时候，获取对象的副本成本非常高。</p>
<h1 id="10-Inheritance"><a href="#10-Inheritance" class="headerlink" title="10.Inheritance"></a>10.Inheritance</h1><p>继承是面向对象语言的特性， 考如下两个Objective-C类，其中一个继承自另一个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@interface Person : NSObject</div><div class="line">@end</div><div class="line"></div><div class="line">@interface Employee : Person</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>C++中对继承也有相似的表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Person &#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class Employee : public Person &#123;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>C ++的唯一区别是添加<code>public</code>关键字。 在这里，<code>Employee</code>从<code>Person</code>继承，这意味着<code>Person</code>中的public属性的成员变量在<code>Employee</code>中保持public。</p>
<p>如果你用<strong>private</strong>替换<strong>public</strong>，那么Person的公共成员将在Employee中变为私有的。 有关此主题的更多信息，建议阅读<a href="http://www.learncpp.com/cpp-tutorial/115-inheritance-and-access-specifiers/" target="_blank" rel="external">inheritance and access specifiers here.</a>。</p>
<p>这是继承的基础部分，C ++与Objective-C不同之处在于它允许多重继承（<strong>multiple inheritance</strong>）。 这允许类从两个或更多个基类继承。 这可能对你来说似乎是陌生的，特别是如果你没有使用Objective-C以外的语言。这儿有一个多继承的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Player &#123;</div><div class="line">    void play();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class Manager &#123;</div><div class="line">    void manage();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class PlayerManager : public Player, public Manager &#123;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在这个例子中，有两个基类和一个继承自它们的类。 这意味着<code>PlayerManager</code>可以访问每个基类的所有成员变量和函数。呃，我确定你很痛苦地意识到，Objective-C无法做到这一点。</p>
<p>细心的读者会注意到Objective-C中有类似的东西：<code>protocol</code>。 尽管与多重继承不完全相同，但是这两种技术都旨在解决相同的问题：<strong>提供一种将几个类链接在一起的机制</strong>。</p>
<p><code>protocol</code>略有不同，因为它没有实现; 相反，它只是描述类的接口应该遵循的规范。</p>
<p>在Objective-C中，上面的例子可以写成如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@protocol Player</div><div class="line">- (void)play;</div><div class="line">@end</div><div class="line"></div><div class="line">@protocol Manager</div><div class="line">- (void)manage;</div><div class="line">@end</div><div class="line"></div><div class="line">@interface Player : NSObject &lt;Player&gt;</div><div class="line">@end</div><div class="line"></div><div class="line">@interface Manager : NSObject &lt;Manager&gt;</div><div class="line">@end</div><div class="line"></div><div class="line">@interface PlayerManager : NSObject &lt;Player, Manager&gt;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>当然，这是非常轻微的设计，但你得到的照片。 在Objective-C中，您必须在PlayerManager类中实现播放和管理，而在C++中，您将仅在每个基类中实现该方法，然后PlayerManager类将自动继承每个实现。</p>
<p>实际上，多重继承有时会导致混乱和复杂化。 在C++开发人员中经常被认为是一个危险的工具，除非绝对必要，否则不惜一切代价避免。</p>
<p>为什么？ 考虑如果两个基类实现了一个具有相同名称并且接受相同参数的函数 - 即两者都将具有相同的原型，那可能会发生什么? 在这种情况下，您需要一种消除歧义的方法。 例如，假设Player和Manager类都有一个名为foo的函数。</p>
<p>你需要消除歧义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PlayerManager p;</div><div class="line">p.foo();          ///&lt; Error! Which foo?</div><div class="line">p.Player::foo();  ///&lt; Call foo from Player</div><div class="line">p.Manager::foo(); ///&lt; Call foo from Manager</div></pre></td></tr></table></figure>
<p>这当然是可行的，但它增加了混乱和一层复杂性，这是最好的避免。 该决定取决于PlayerManager的用户。 使用协议留给PlayerManager类实现foo，所以只有一个实现 ，不会产生歧义。</p>
<h1 id="11-Where-to-Go-From-Here"><a href="#11-Where-to-Go-From-Here" class="headerlink" title="11.Where to Go From Here?"></a>11.Where to Go From Here?</h1><p>在本系列的第一部分，您学习了C ++的简史，如何声明一个类以及内存管理如何在C ++中运行。 当然还有比这更多的语言！</p>
<p>在本系列的<a href="https://www.raywenderlich.com/62989/introduction-c-ios-developers-part-1" target="_blank" rel="external">第二部分</a>，您将在了解标准库和Objective-C++之前，先了解更多高级类的功能和模板。</p>
<p>在此期间，如果您对C ++的冒险有任何问题或意见，请加入下面的讨论！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/14/SDK/SDK开发实践01：开篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tank">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://www.vstou.com/upload/image/355/201606/1465004143320282.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tankxie's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/14/SDK/SDK开发实践01：开篇/" itemprop="url">SDK开发实践01：开篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-14T21:16:34+08:00">
                2017-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SDK开发/" itemprop="url" rel="index">
                    <span itemprop="name">SDK开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iOS native小组在SDK输出这条路上摸爬滚打一年多了，可披荆斩棘，写个文档mark一下，以飨来者，也欢迎大牛交流指点。</p>
<h2 id="文档结构"><a href="#文档结构" class="headerlink" title="文档结构"></a>文档结构</h2><p>iOS SDK开发实践系列计划写6篇：</p>
<ol>
<li>iOS SDK开发实践01：开篇</li>
<li>iOS SDK开发实践02：SDK接口设计原则，如何处理SDK中的依赖</li>
<li>iOS SDK开发实践03：cocopods私有库管理代码、打包</li>
<li>iOS SDK开发实践04：fastlane自动化实践</li>
<li>iOS SDK开发实践05：容易踩的坑</li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>实践过程凝结了无数人的汗水，@adamschen、@brownfeng、@danecai。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/14/SDK/SDK开发实践02：SDK接口设计原则/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tank">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://www.vstou.com/upload/image/355/201606/1465004143320282.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tankxie's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/14/SDK/SDK开发实践02：SDK接口设计原则/" itemprop="url">SDK开发实践02：SDK接口设计原则</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-14T21:16:34+08:00">
                2017-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SDK开发/" itemprop="url" rel="index">
                    <span itemprop="name">SDK开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇主要讲如下内容</p>
<ul>
<li>SDK接口设计原则</li>
<li>SDK设计中的代码规范</li>
</ul>
<h2 id="SDK接口设计原则"><a href="#SDK接口设计原则" class="headerlink" title="SDK接口设计原则"></a>SDK接口设计原则</h2><h3 id="一、-遵循面向对象的设计原则"><a href="#一、-遵循面向对象的设计原则" class="headerlink" title="一、 遵循面向对象的设计原则"></a>一、 遵循面向对象的设计原则</h3><p>对于面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题，如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。<br>在面向对象设计中，可维护性的复用是以设计原则为基础的。每一个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升一个软件结构的设计水平。<br>最常见的7种面向对象设计原则如下：</p>
<ul>
<li>单一职责原则 (Single Responsibility Principle, SRP)</li>
<li>开闭原则 (Open-Closed Principle, OCP)</li>
<li>里氏代换原则 (Liskov Substitution Principle, LSP)</li>
<li>依赖倒转原则 (Dependence Inversion Principle, DIP)</li>
<li>接口隔离原则 (Interface Segregation Principle, ISP)</li>
<li>合成复用原则 (Composite Reuse Principle, CRP)</li>
<li>迪米特法则 (Law of Demeter, LoD)</li>
</ul>
<p>详细请参考<a href="https://quanke.gitbooks.io/design-pattern-java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99.html" target="_blank" rel="external">面向对象设计原则</a>。</p>
<h3 id="二、-实践"><a href="#二、-实践" class="headerlink" title="二、 实践"></a>二、 实践</h3><blockquote>
<p>本篇设计的SDK名字为<code>XXXService</code>。</p>
</blockquote>
<h4 id="1-对外接口设计单例类，保证一个类仅有一个实例，并提供一个访问它的全局访问点"><a href="#1-对外接口设计单例类，保证一个类仅有一个实例，并提供一个访问它的全局访问点" class="headerlink" title="1. 对外接口设计单例类，保证一个类仅有一个实例，并提供一个访问它的全局访问点"></a>1. 对外接口设计单例类，保证一个类仅有一个实例，并提供一个访问它的全局访问点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @brief XXXService单例方法</div><div class="line"> *</div><div class="line"> * @return XXXService对象</div><div class="line"> */</div><div class="line">+ (nonnull instancetype) sharedService;</div></pre></td></tr></table></figure>
<h4 id="2-头文件设计"><a href="#2-头文件设计" class="headerlink" title="2. 头文件设计"></a>2. 头文件设计</h4><p>按照个人习惯，一般会暴露<code>XXXService.h</code>,<code>XXXConfig.h</code>和<code>XXXModel.h</code>中的一个或多个头文件给外部。<br>顾名思义，一个提供SDK入口，一个提供SDK配置，一个提供SDK数据模型。</p>
<h4 id="3-入口方法的设计"><a href="#3-入口方法的设计" class="headerlink" title="3. 入口方法的设计"></a>3. 入口方法的设计</h4><p>第三方APP和SDK之间的数据传递：</p>
<ul>
<li>第三方在调起SDK的时候需要向SDK传递参数</li>
<li>SDK在调用完成之后需要给结果数据到第三方</li>
</ul>
<p><img src="/2017/08/14/SDK/SDK开发实践02：SDK接口设计原则/2.png" alt="命名前缀前缀"></p>
<p>前者可以通过<strong>实例方法的参</strong>数或者<strong>@property</strong>两种方法实现；<br>后者一般可以通过<strong>delegate</strong>或者<strong>block</strong>两种方法来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* @brief 调起SDK入口方法</div><div class="line"></div><div class="line">* @param manageVC          SDK的入口页面对应的view controller</div><div class="line">* @param config            配置参数</div><div class="line">* @param delegate          代理</div><div class="line">* ...</div><div class="line">* @param startSucceed      启动SDK成功回调</div><div class="line">* @param failed            启动SDK异常回调</div><div class="line">*/</div><div class="line">typedef void(^XXXServiceStartSucceedBlock)();</div><div class="line">typedef void(^XXXServiceFailedBlock) (NSError * _Nonnull error);</div><div class="line"></div><div class="line">- (void)startXXXServiceWithManageVC:(nonnull UIViewController *)manageVc</div><div class="line">                             config:(nullable XXXConfig *)config</div><div class="line">                           delegate:(nonnull id) delegate</div><div class="line">                              appId:(nonnull NSString *)appId</div><div class="line">                              nonce:(nonnull NSString *)nonce</div><div class="line">                             userId:(nonnull NSString *)userId</div><div class="line">                               sign:(nonnull NSString*)sign</div><div class="line">                            orderNo:(nonnull NSString *)orderNo</div><div class="line">                       startSucceed:(nullable XXXServiceStartSucceedBlock)startSucceed</div><div class="line">                             failed:(nullable XXXServiceFailedBlock)failed;</div><div class="line">// 外部主动退出SDK方法</div><div class="line">- (void)stopService;</div></pre></td></tr></table></figure>
<p>个人比较倾向于，把启动SDK需要的参数，放在启动方法的参数里面，并用<code>nullable</code>和<code>nonnull</code>来表示必传参数和可选参数。</p>
<p>然后用<code>startSucceed</code>和<code>failed</code>两个block来分别传递调起SDK成功和失败回调信息。</p>
<p>用delegate向外传递业务结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@protocol XXXProtocol &lt;NSObject&gt;</div><div class="line">- (void)XXXServiceWillExitWith:(XXXModel *)info;</div><div class="line">- (void)XXXServiceDidExitWith:(XXXModel *)info;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<h2 id="SDK编码命名规范"><a href="#SDK编码命名规范" class="headerlink" title="SDK编码命名规范"></a>SDK编码命名规范</h2><h3 id="iOS编码规范"><a href="#iOS编码规范" class="headerlink" title="iOS编码规范"></a>iOS编码规范</h3><p>iOS编码权威规范参考<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html" target="_blank" rel="external">Introduction to Coding Guidelines for Cocoa</a>。</p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>针对SDK输出过程中遇到的一些问题，总结下面几条：</p>
<h4 id="注意前缀命名规范"><a href="#注意前缀命名规范" class="headerlink" title="注意前缀命名规范"></a>注意前缀命名规范</h4><p>冲突从两个范畴来讲：</p>
<ul>
<li>内部业务模块之间</li>
</ul>
<p><img src="/2017/08/14/SDK/SDK开发实践02：SDK接口设计原则/1.png" alt="命名前缀前缀"></p>
<p>需要注意的有类名以及bundle名。<br>这样可以避免代码和外部代码以及内部其它产品代码冲突。<br>在SDK输出打包的时候对所包含的类名统一加前缀，这一part在后面cocopod打包的时候说。</p>
<h4 id="category的使用"><a href="#category的使用" class="headerlink" title="category的使用"></a>category的使用</h4><p>不建议在SDK内部使用category，category会load到外部的方法，举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// SDK 内部使用了一个UIColor的category</div><div class="line">// 支持的颜色格式是@&quot;ffffff&quot;，只支持这种输入。</div><div class="line">- (void)colorWithString:(NSString *)color;</div><div class="line"></div><div class="line">// 外部APP也有一个UIColor的category</div><div class="line">// 但支持的颜色格式是@&quot;0xffffff&quot;</div><div class="line">- (void)colorWithString:(NSString *)color;</div><div class="line"></div><div class="line">// 外部APP在调用的时候</div><div class="line">[UIColor colorWithString:@&quot;0x000000&quot;];</div></pre></td></tr></table></figure>
<p>这样就有可能gg了，可能会出现颜色设置不上去，甚至是cash。<br>解决方案有二：<br>一是，在SDK里面不用category；<br>二是，万一要用，对方法加前缀吧,类似这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)wb_colorWithString:(NSString *)color;</div></pre></td></tr></table></figure>
<h2 id="SDK对UI的处理"><a href="#SDK对UI的处理" class="headerlink" title="SDK对UI的处理"></a>SDK对UI的处理</h2><h3 id="SDK出现的形式"><a href="#SDK出现的形式" class="headerlink" title="SDK出现的形式"></a>SDK出现的形式</h3><p>一般SDK页面会提供，两种SDK页面出现的方式：</p>
<ul>
<li>push页面</li>
<li>present页面</li>
</ul>
<h3 id="对navigation-bar这种全局UI的处理"><a href="#对navigation-bar这种全局UI的处理" class="headerlink" title="对navigation bar这种全局UI的处理"></a>对navigation bar这种全局UI的处理</h3><p>不污染原则，修改完之后要复原。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://www.vstou.com/upload/image/355/201606/1465004143320282.jpg"
               alt="tank" />
          <p class="site-author-name" itemprop="name">tank</p>
           
              <p class="site-description motion-element" itemprop="description">大道理很多人都懂，为何脱颖而出的就那么几个人，因为他们不只懂而且也去做了。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tank</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
